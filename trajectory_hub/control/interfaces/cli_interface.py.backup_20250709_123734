"""
CLI Interface Helper - Maneja entrada/salida de consola
"""
from typing import Optional, List, Dict, Any
import os


class CLIInterface:
    """Helper para interfaz de l√≠nea de comandos"""
    
    def __init__(self):
        self.last_input = None
        
    def clear_screen(self):
        """Limpia la pantalla"""
        os.system('cls' if os.name == 'nt' else 'clear')
    
    def get_input(self, prompt: str = "Selecci√≥n: ") -> str:
        """Obtiene entrada del usuario"""
        try:
            self.last_input = input(f"\n{prompt}").strip()
            return self.last_input
        except KeyboardInterrupt:
            return 'q'
    
    def get_numeric_input(self, prompt: str, min_val: float = None, 
                         max_val: float = None) -> Optional[float]:
        """Obtiene entrada num√©rica con validaci√≥n"""
        while True:
            value = self.get_input(prompt)
            if value.lower() == 'q':
                return None
                
            try:
                num = float(value)
                if min_val is not None and num < min_val:
                    self.show_error(f"Valor m√≠nimo: {min_val}")
                    continue
                if max_val is not None and num > max_val:
                    self.show_error(f"Valor m√°ximo: {max_val}")
                    continue
                return num
            except ValueError:
                self.show_error("Por favor ingrese un n√∫mero v√°lido")
    
    def get_choice_from_list(self, options: List[str], 
                           prompt: str = "Seleccione una opci√≥n:") -> Optional[int]:
        """Muestra lista y obtiene selecci√≥n"""
        print(f"\n{prompt}")
        for i, option in enumerate(options, 1):
            print(f"  {i}. {option}")
        
        choice = self.get_numeric_input("Opci√≥n: ", 1, len(options))
        return int(choice) - 1 if choice else None
    
    def get_yes_no(self, prompt: str) -> bool:
        """Obtiene respuesta s√≠/no"""
        response = self.get_input(f"{prompt} (s/n): ").lower()
        return response in ['s', 'si', 's√≠', 'y', 'yes']
    
    def show_header(self, title: str):
        """Muestra encabezado formateado"""
        print(f"\n{'=' * 60}")
        print(f"{title.center(60)}")
        print('=' * 60)
    
    def show_success(self, message: str):
        """Muestra mensaje de √©xito"""
        print(f"\n‚úÖ {message}")
    
    def show_error(self, message: str):
        """Muestra mensaje de error"""
        print(f"\n‚ùå ERROR: {message}")
    
    def show_warning(self, message: str):
        """Muestra advertencia"""
        print(f"\n‚ö†Ô∏è  ADVERTENCIA: {message}")
    
    def show_info(self, message: str):
        """Muestra informaci√≥n"""
        print(f"\n‚ÑπÔ∏è  {message}")
    
    def show_menu(self, title: str, options: List[tuple]):
        """Muestra un men√∫ formateado"""
        self.show_header(title)
        for key, description in options:
            if key == '-':
                print(f"{'-' * 60}")
            else:
                print(f"  {key:<4} {description}")
    
    def pause(self, message: str = "Presione ENTER para continuar..."):
        """Pausa la ejecuci√≥n"""
        input(f"\n{message}")
    
    def get_macro_config(self) -> Optional[Dict[str, Any]]:
        """Obtiene configuraci√≥n para crear un macro"""
        print("\nüîß CONFIGURACI√ìN DE MACRO")
        
        name = self.get_input("Nombre del macro: ")
        if not name or name == 'q':
            return None
            
        count = self.get_numeric_input("N√∫mero de fuentes: ", 1, 100)
        if count is None:
            return None
            
        formations = ["circle", "line", "grid", "spiral", "random"]
        formation_idx = self.get_choice_from_list(formations, "Formaci√≥n inicial:")
        if formation_idx is None:
            return None
            
        return {
            "name": name,
            "source_count": int(count),
            "formation": formations[formation_idx]
        }
    
    def get_movement_config(self) -> Optional[Dict[str, Any]]:
        """Obtiene configuraci√≥n de movimiento"""
        print("\nüåÄ CONFIGURACI√ìN DE MOVIMIENTO")
        
        types = ["circle", "spiral", "figure8", "lissajous", "random"]
        type_idx = self.get_choice_from_list(types, "Tipo de trayectoria:")
        if type_idx is None:
            return None
            
        speed = self.get_numeric_input("Velocidad (0.1-10): ", 0.1, 10)
        if speed is None:
            return None
            
        return {
            "trajectory_type": types[type_idx],
            "speed": speed
        }
