<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Continuous Painted Focus & Particle Trail Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- Incluir three.js y dat.GUI -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
  <script>
    // Escena, cámara y renderizador
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    const baseCameraPosition = new THREE.Vector3(0, 0, 8);
    camera.position.copy(baseCameraPosition);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Reloj para medir el delta
    const clock = new THREE.Clock();

    // Parámetros de la simulación
    const params = {
      movementSpeed: 1.0,          // Velocidad de rotación
      rotationIntensity: 1.0,      // Intensidad (0 a 1)
      drawingMode: "Lissajous",    // Opciones: "Circle", "Ellipse", "Lissajous", "Spiral" (se mantiene para el cálculo de color)
      particleLifetime: 2.0,       // Tiempo de vida de cada partícula (segundos)
      spawnRate: 500,              // Puntos generados por segundo (más alto = estela más continua)
      radiationSize: 0.0,          // 0 (mínimo) a 1 (máximo: foco cubre la esfera)
      cameraOffset: { x: 0, y: 0, z: 0 }  // Offset que se aplica a la cámara
    };

    // Controles con dat.GUI
    const gui = new dat.GUI();
    gui.add(params, "movementSpeed", 0.1, 5.0).name("Movement Speed");
    gui.add(params, "rotationIntensity", 0, 1.0).name("Rotation Intensity");
    gui.add(params, "drawingMode", ["Circle", "Ellipse", "Lissajous", "Spiral"]).name("Drawing Mode");
    gui.add(params, "particleLifetime", 0.5, 5.0).name("Trail Lifetime");
    gui.add(params, "spawnRate", 10, 1000).name("Spawn Rate (pts/sec)");
    gui.add(params, "radiationSize", 0.0, 1.0).name("Radiation Size");
    gui.add(params.cameraOffset, "x", -5, 5).name("Camera Offset X");
    gui.add(params.cameraOffset, "y", -5, 5).name("Camera Offset Y");
    gui.add(params.cameraOffset, "z", -5, 5).name("Camera Offset Z");

    // Crear esfera de referencia (wireframe)
    const sphereRadius = 2;
    const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 32, 32);
    const sphereMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      wireframe: true,
      opacity: 0.3,
      transparent: true
    });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    scene.add(sphere);

    // Foco de radiación: un círculo pintado en la superficie de la esfera
    // Ahora se ubicará en el ecuador (posición fija en el eje X, es decir: (sphereRadius, 0, 0))
    const focusBaseRadius = 0.05; // Radio base del foco
    const focusGeometry = new THREE.CircleGeometry(focusBaseRadius, 32);
    const focusMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true });
    const focusMesh = new THREE.Mesh(focusGeometry, focusMaterial);
    // Se añade como hijo de la esfera para que se mueva solidariamente
    sphere.add(focusMesh);

    // Función para actualizar la posición y orientación del foco.
    // Ahora se fija en el ecuador, es decir, en (sphereRadius, 0, 0) en coordenadas locales de la esfera.
    function updateFocusPosition() {
      const localPos = new THREE.Vector3(sphereRadius, 0, 0);
      focusMesh.position.copy(localPos);
      // Orientamos el foco para que "se adhiera" a la esfera:
      // El vector radial es (1, 0, 0) y la geometría del círculo se crea en el plano XY (normal (0,0,1)).
      const desiredNormal = localPos.clone().normalize(); // Será (1,0,0)
      const defaultNormal = new THREE.Vector3(0, 0, 1);
      const quaternion = new THREE.Quaternion().setFromUnitVectors(defaultNormal, desiredNormal);
      focusMesh.quaternion.copy(quaternion);
    }

    // Calcular la escala del foco para que, a valor máximo, su diámetro coincida con el de la esfera.
    const baseScale = 1;
    const maxScale = (2 * sphereRadius) / (2 * focusBaseRadius);
    function getFocusScale() {
      return baseScale + params.radiationSize * (maxScale - baseScale);
    }

    // --- Sistema de partículas para la estela ---
    // Usamos THREE.Points con BufferGeometry para simular un trazo continuo mediante muchas partículas.
    const maxTrailPoints = 2000;
    const trailPositions = new Float32Array(maxTrailPoints * 3);
    const trailColors = new Float32Array(maxTrailPoints * 3);
    const trailGeometry = new THREE.BufferGeometry();
    trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
    trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
    trailGeometry.setDrawRange(0, 0);

    // Cargar una textura circular para que las partículas sean redondeadas.
    const textureLoader = new THREE.TextureLoader();
    const particleTexture = textureLoader.load('https://threejs.org/examples/textures/sprites/disc.png');

    const trailMaterial = new THREE.PointsMaterial({
      map: particleTexture,
      size: 0.1, // Se actualizará dinámicamente para igualar el foco
      vertexColors: true,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthTest: false
    });
    const trailPointsMesh = new THREE.Points(trailGeometry, trailMaterial);
    scene.add(trailPointsMesh);

    // Array para almacenar cada punto de la estela: { position, time, color }
    const trail = [];

    // Función que devuelve un color dinámico para un punto del trazo.
    // Se mantiene el cálculo basado en drawingMode para dar variedad a los colores.
    function getTrailColor() {
      const t = performance.now() * 0.001;
      let hue;
      switch (params.drawingMode) {
        case "Circle":
          hue = (t * 50) % 360;
          break;
        case "Ellipse":
          hue = (t * 70) % 360;
          break;
        case "Lissajous":
          hue = (t * 90) % 360;
          break;
        case "Spiral":
          hue = (t * 110) % 360;
          break;
        default:
          hue = (t * 50) % 360;
      }
      return new THREE.Color("hsl(" + hue + ", 100%, 50%)");
    }

    // Actualizar la geometría de la estela a partir de los puntos acumulados
    function updateTrailGeometry(currentTime) {
      const numPoints = trail.length;
      trailGeometry.setDrawRange(0, numPoints);
      for (let i = 0; i < numPoints; i++) {
        const p = trail[i];
        trailPositions[i * 3]     = p.position.x;
        trailPositions[i * 3 + 1] = p.position.y;
        trailPositions[i * 3 + 2] = p.position.z;
        // Calcular el "fade" según la edad del punto
        const age = currentTime - p.time;
        let alpha = 1.0 - (age / params.particleLifetime);
        alpha = Math.max(alpha, 0);
        // Aplicar el fade al color
        trailColors[i * 3]     = p.color.r * alpha;
        trailColors[i * 3 + 1] = p.color.g * alpha;
        trailColors[i * 3 + 2] = p.color.b * alpha;
      }
      trailGeometry.attributes.position.needsUpdate = true;
      trailGeometry.attributes.color.needsUpdate = true;
    }

    // Ajustar tamaño de la ventana
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    let spawnAccumulator = 0;
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const currentTime = clock.elapsedTime;

      // Actualizar la posición de la cámara según el offset
      camera.position.copy(baseCameraPosition).add(new THREE.Vector3(
        params.cameraOffset.x,
        params.cameraOffset.y,
        params.cameraOffset.z
      ));
      camera.lookAt(0, 0, 0);

      // Rotar la esfera (aplicando pitch, yaw y roll)
      const t = currentTime;
      sphere.rotation.x = Math.sin(t * params.movementSpeed) * params.rotationIntensity;
      sphere.rotation.y = Math.cos(t * params.movementSpeed) * params.rotationIntensity;
      sphere.rotation.z = Math.sin(t * params.movementSpeed * 0.5) * params.rotationIntensity;

      // Actualizar posición y orientación del foco
      updateFocusPosition();

      // Escalar el foco según el parámetro radiationSize
      const scale = getFocusScale();
      focusMesh.scale.set(scale, scale, scale);

      // Obtener la posición global del foco
      const globalPos = new THREE.Vector3();
      focusMesh.getWorldPosition(globalPos);

      // Generar puntos para la estela a alta frecuencia (spawnRate puntos por segundo)
      spawnAccumulator += params.spawnRate * delta;
      while (spawnAccumulator >= 1) {
        spawnAccumulator -= 1;
        trail.push({
          position: globalPos.clone(),
          time: currentTime,
          color: getTrailColor()
        });
      }
      // Eliminar puntos antiguos que excedan la vida configurada
      while (trail.length > 0 && currentTime - trail[0].time > params.particleLifetime) {
        trail.shift();
      }

      // *** IMPORTANTE: Actualizamos el último punto de la estela para que siempre coincida con el foco ***
      if(trail.length > 0) {
        const last = trail[trail.length - 1];
        last.position.copy(globalPos);
        last.time = currentTime;
        last.color = getTrailColor();
      }

      // Actualizar la geometría de la estela
      updateTrailGeometry(currentTime);

      // Ajustar el tamaño de las partículas para que coincida con el foco
      const effectiveFocusRadius = focusBaseRadius * scale;
      trailMaterial.size = effectiveFocusRadius * 2;

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
