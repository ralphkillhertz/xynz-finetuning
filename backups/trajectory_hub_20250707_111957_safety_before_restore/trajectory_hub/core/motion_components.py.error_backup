"""
motion_components.py - Componentes de movimiento actualizados con modulador 3D avanzado
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Optional, Callable, Dict, List, Tuple
import numpy as np
from .movement_modes import MovementModeMixin, TrajectoryMovementMode
import time
import logging
from enum import Enum

logger = logging.getLogger(__name__)


@dataclass
class MotionState:
    """Estado completo del movimiento de una fuente"""
    position: np.ndarray = field(default_factory=lambda: np.zeros(3))
    orientation: np.ndarray = field(default_factory=lambda: np.zeros(3))  # yaw, pitch, roll
    aperture: float = 0.5
    
    # Velocidades para interpolación suave
    velocity: np.ndarray = field(default_factory=lambda: np.zeros(3))
    angular_velocity: np.ndarray = field(default_factory=lambda: np.zeros(3))
    
    # Timestamp para interpolación
    last_update: float = 0.0



# Enums para el sistema de concentración
class ConcentrationMode(Enum):
    """Modos de concentración"""
    FIXED_POINT = "fixed_point"      # Punto fijo en el espacio
    FOLLOW_MACRO = "follow_macro"    # Sigue la trayectoria macro
    DYNAMIC = "dynamic"              # Punto calculado dinámicamente

class ConcentrationCurve(Enum):
    """Curvas de transición"""
    LINEAR = "linear"
    EASE_IN = "ease_in"
    EASE_OUT = "ease_out"
    EASE_IN_OUT = "ease_in_out"
    EXPONENTIAL = "exponential"
    BOUNCE = "bounce"

class MotionComponent(ABC):
    """Componente base para todos los tipos de movimiento"""
    
    def __init__(self, name: str = ""):
        # Offsets para arquitectura de deltas
        self.concentration_offset = np.zeros(3)
        self.macro_rotation_offset = np.zeros(3)
        self.trajectory_offset = np.zeros(3)
        self.algorithmic_rotation_offset = np.zeros(3)
                self.name = name
        self.enabled = True
        self.weight = 1.0  # Para mezclar múltiples componentes
        
    @abstractmethod
        def update(self, dt: float):
        """Actualizar posición usando arquitectura de DELTAS (suma)"""
        if dt < 0.0001:
            return
            
        # Resetear offsets
        self.concentration_offset = np.zeros(3)
        self.macro_rotation_offset = np.zeros(3)
        self.trajectory_offset = np.zeros(3)
        self.algorithmic_rotation_offset = np.zeros(3)
        
        # 1. Calcular offset de trayectoria individual (IS)
        if 'individual_trajectory' in self.components:
            traj = self.components['individual_trajectory']
            if traj.enabled:
                self.trajectory_offset = traj.get_position(self.time) - self.base_position
        
        # 2. Calcular offset de concentración
        if 'concentration' in self.components:
            conc = self.components['concentration']
            if conc.enabled and conc.factor < 0.99:
                target = conc.target_point
                current = self.get_position()
                # Interpolar hacia el punto de concentración
                concentrated = current * conc.factor + target * (1 - conc.factor)
                self.concentration_offset = concentrated - current
        
        # 3. Calcular offset de rotación del macro (MS)
        if 'macro_rotation' in self.components:
            rot = self.components['macro_rotation']
            if rot.enabled:
                # Aplicar rotación alrededor del centro del macro
                angle = rot.angle
                center = rot.center
                current = self.get_position()
                
                # Rotar alrededor del centro
                relative = current - center
                cos_a, sin_a = np.cos(angle), np.sin(angle)
                
                if rot.axis == 'yaw':  # Rotación en Z
                    rotated = np.array([
                        relative[0] * cos_a - relative[1] * sin_a,
                        relative[0] * sin_a + relative[1] * cos_a,
                        relative[2]
                    ])
                elif rot.axis == 'pitch':  # Rotación en Y
                    rotated = np.array([
                        relative[0] * cos_a + relative[2] * sin_a,
                        relative[1],
                        -relative[0] * sin_a + relative[2] * cos_a
                    ])
                else:  # roll - Rotación en X
                    rotated = np.array([
                        relative[0],
                        relative[1] * cos_a - relative[2] * sin_a,
                        relative[1] * sin_a + relative[2] * cos_a
                    ])
                
                self.macro_rotation_offset = (rotated + center) - current
        
        # 4. Calcular offset de rotación algorítmica
        if 'algorithmic_rotation' in self.components:
            algo_rot = self.components['algorithmic_rotation']
            if algo_rot.enabled:
                # Aplicar patrón de rotación
                self.algorithmic_rotation_offset = algo_rot.get_offset(self.time)
        
        # Actualizar tiempo
        self.time += dt
    
    def get_position(self) -> np.ndarray:
        """Obtener posición final sumando TODOS los componentes"""
        return (self.base_position + 
                self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
    
    def _combine_components(self) -> np.ndarray:
        """Combinar todos los offsets (método auxiliar)"""
        return (self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
class OrientationModulation(MotionComponent):
    """
    Nivel 1: Modulación de orientación básica (yaw, pitch, roll)
    La fuente gira sobre sí misma sin mover su centro
    """
    
    def __init__(self):
        super().__init__("orientation_modulation")
        self.yaw_func: Optional[Callable[[float], float]] = None
        self.pitch_func: Optional[Callable[[float], float]] = None
        self.roll_func: Optional[Callable[[float], float]] = None
        self._orientation_update_threshold = 0.01  # Umbral para actualizar orientación
        self._aperture_update_threshold = 0.01  # Umbral para actualizar apertura
        self.smoothing = 0.1  # Suavizado de cambios
    def set_modulation(self, 
                      yaw: Optional[Callable] = None,
                      pitch: Optional[Callable] = None, 
                      roll: Optional[Callable] = None):
        """Configurar funciones de modulación"""
        if yaw:
            self.yaw_func = yaw
        if pitch:
            self.pitch_func = pitch
        if roll:
            self.roll_func = roll
            
        def update(self, dt: float):
        """Actualizar posición usando arquitectura de DELTAS (suma)"""
        if dt < 0.0001:
            return
            
        # Resetear offsets
        self.concentration_offset = np.zeros(3)
        self.macro_rotation_offset = np.zeros(3)
        self.trajectory_offset = np.zeros(3)
        self.algorithmic_rotation_offset = np.zeros(3)
        
        # 1. Calcular offset de trayectoria individual (IS)
        if 'individual_trajectory' in self.components:
            traj = self.components['individual_trajectory']
            if traj.enabled:
                self.trajectory_offset = traj.get_position(self.time) - self.base_position
        
        # 2. Calcular offset de concentración
        if 'concentration' in self.components:
            conc = self.components['concentration']
            if conc.enabled and conc.factor < 0.99:
                target = conc.target_point
                current = self.get_position()
                # Interpolar hacia el punto de concentración
                concentrated = current * conc.factor + target * (1 - conc.factor)
                self.concentration_offset = concentrated - current
        
        # 3. Calcular offset de rotación del macro (MS)
        if 'macro_rotation' in self.components:
            rot = self.components['macro_rotation']
            if rot.enabled:
                # Aplicar rotación alrededor del centro del macro
                angle = rot.angle
                center = rot.center
                current = self.get_position()
                
                # Rotar alrededor del centro
                relative = current - center
                cos_a, sin_a = np.cos(angle), np.sin(angle)
                
                if rot.axis == 'yaw':  # Rotación en Z
                    rotated = np.array([
                        relative[0] * cos_a - relative[1] * sin_a,
                        relative[0] * sin_a + relative[1] * cos_a,
                        relative[2]
                    ])
                elif rot.axis == 'pitch':  # Rotación en Y
                    rotated = np.array([
                        relative[0] * cos_a + relative[2] * sin_a,
                        relative[1],
                        -relative[0] * sin_a + relative[2] * cos_a
                    ])
                else:  # roll - Rotación en X
                    rotated = np.array([
                        relative[0],
                        relative[1] * cos_a - relative[2] * sin_a,
                        relative[1] * sin_a + relative[2] * cos_a
                    ])
                
                self.macro_rotation_offset = (rotated + center) - current
        
        # 4. Calcular offset de rotación algorítmica
        if 'algorithmic_rotation' in self.components:
            algo_rot = self.components['algorithmic_rotation']
            if algo_rot.enabled:
                # Aplicar patrón de rotación
                self.algorithmic_rotation_offset = algo_rot.get_offset(self.time)
        
        # Actualizar tiempo
        self.time += dt
    
    def get_position(self) -> np.ndarray:
        """Obtener posición final sumando TODOS los componentes"""
        return (self.base_position + 
                self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
    
    def _combine_components(self) -> np.ndarray:
        """Combinar todos los offsets (método auxiliar)"""
        return (self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
class AdvancedOrientationModulation(OrientationModulation):
    """
    Modulación avanzada con soporte para P1, P2, P3
    P1: Forma de modulación (combinación de m1, m2, m3)
    P2: Velocidad de modulación (LFO)
    P3: Directividad (Aperture)
    """
    
    def __init__(self, source_id: Optional[int] = None):
        super().__init__()
        self.name = "advanced_orientation_modulation"
        self.source_id = source_id  # ID de la fuente asociada
        self.source_id = source_id  # ID de la fuente asociada
        
        # Parámetros P1 (Forma)
        self.modulation_shape = "circular"  # linear, arc, circular, spiral, lissajous
        self.shape_scale = np.array([1.0, 1.0, 1.0])  # m2(a,b,c) - escala en cada eje
        self.shape_translation = np.array([0.0, 0.0, 0.0])  # m2(d,e) - offset
        self.rotation_mode = "none"  # none, circular, so3
        
        # Parámetros P2 (Velocidad)
        self.lfo_frequency = 0.5  # Hz
        self.lfo_phase = 0.0
        
        # Parámetros P3 (Directividad)
        self.aperture_base = 0.5
        self.aperture_modulation = 0.0
        
        # Control de intensidad global (C2)
        self.intensity = 1.0  # 0.0 a 1.0
        
        # Parámetros internos
        self.time_offset = 0.0
        self.noise_seed = np.random.random()
        
        # Presets predefinidos (alineados con el simulador)
        self.presets = {
            "circle": {
                "shape": "circle",
                "scale": [0.5, 0.5, 0.2],
                "translation": [0.0, 0.0, 0.0],
                "lfo": 1.0,
                "aperture": 0.5,
                "aperture_mod": 0.1,
                "description": "Movimiento circular simple"
            },
            "ellipse": {
                "shape": "ellipse",
                "scale": [0.7, 0.4, 0.1],
                "translation": [0.0, 0.0, 0.0],
                "lfo": 0.8,
                "aperture": 0.6,
                "aperture_mod": 0.1,
                "description": "Movimiento elíptico"
            },
            "lissajous": {
                "shape": "lissajous",
                "scale": [1.0, 0.7, 0.5],
                "translation": [0.0, 0.0, 0.0],
                "lfo": 0.3,
                "aperture": 0.5,
                "aperture_mod": 0.15,
                "description": "Figura de Lissajous 3D"
            },
            "spiral": {
                "shape": "spiral",
                "scale": [1.0, 1.0, 0.5],
                "translation": [0.0, 0.0, 0.0],
                "lfo": 0.1,
                "aperture": 0.9,
                "aperture_mod": 0.05,
                "description": "Espiral expansiva"
            },
            "respiración_suave": {
                "shape": "circle",
                "scale": [0.3, 0.3, 0.1],
                "translation": [0.0, 0.0, 0.0],
                "lfo": 0.2,
                "aperture": 0.7,
                "aperture_mod": 0.1,
                "description": "Movimiento circular suave como respiración"
            },
            "nervioso_aleatorio": {
                "shape": "random",
                "scale": [0.1, 0.1, 0.1],
                "translation": [0.0, 0.0, 0.0],
                "lfo": 5.0,
                "aperture": 0.3,
                "aperture_mod": 0.2,
                "description": "Vibraciones nerviosas aleatorias"
            },
            "espiral_cósmica": {
                "shape": "spiral",
                "scale": [1.0, 1.0, 0.5],
                "translation": [0.0, 0.0, 0.0],
                "lfo": 0.1,
                "aperture": 0.9,
                "aperture_mod": 0.05,
                "description": "Espiral expansiva lenta"
            },
            "lissajous_complejo": {
                "shape": "lissajous",
                "scale": [1.0, 0.7, 0.5],
                "translation": [0.0, 0.0, 0.0],
                "lfo": 0.3,
                "aperture": 0.5,
                "aperture_mod": 0.15,
                "description": "Figura de Lissajous 3D compleja"
            },
            "péndulo_hipnótico": {
                "shape": "pendulum",
                "scale": [0.8, 0.0, 0.6],
                "translation": [0.0, 0.0, 0.0],
                "lfo": 0.4,
                "aperture": 0.6,
                "aperture_mod": 0.1,
                "description": "Movimiento pendular hipnótico"
            },
            "vibración_sísmica": {
                "shape": "seismic",
                "scale": [0.2, 0.2, 0.1],
                "translation": [0.0, 0.0, 0.0],
                "lfo": 8.0,
                "aperture": 0.4,
                "aperture_mod": 0.3,
                "description": "Vibraciones sísmicas rápidas"
            },
            "flotación_oceánica": {
                "shape": "ocean",
                "scale": [0.4, 0.3, 0.5],
                "translation": [0.0, 0.0, 0.0],
                "lfo": 0.15,
                "aperture": 0.8,
                "aperture_mod": 0.1,
                "description": "Movimiento ondulante como en el océano"
            },
            "rotación_mecánica": {
                "shape": "mechanical",
                "scale": [1.0, 0.0, 0.0],
                "translation": [0.0, 0.0, 0.0],
                "lfo": 1.0,
                "aperture": 0.2,
                "aperture_mod": 0.0,
                "description": "Rotación mecánica constante"
            }
        }
        
    def apply_preset(self, preset_name: str):
        """Aplicar un preset predefinido"""
        if preset_name in self.presets:
            preset = self.presets[preset_name]
            self.modulation_shape = preset["shape"]
            self.shape_scale = np.array(preset["scale"])
            self.shape_translation = np.array(preset["translation"])
            self.lfo_frequency = preset["lfo"]
            self.aperture_base = preset["aperture"]
            self.aperture_modulation = preset.get("aperture_mod", 0.0)
            logger.info(f"Preset '{preset_name}' aplicado: {preset['description']}")            
    def interpolate_presets(self, preset1: str, preset2: str, factor: float):
        """Interpolar entre dos presets (0.0 = preset1, 1.0 = preset2)"""
        if preset1 in self.presets and preset2 in self.presets:
            p1 = self.presets[preset1]
            p2 = self.presets[preset2]
            
            # Interpolar parámetros numéricos
            self.shape_scale = np.array(p1["scale"]) * (1-factor) + np.array(p2["scale"]) * factor
            self.shape_translation = np.array(p1["translation"]) * (1-factor) + np.array(p2["translation"]) * factor
            self.lfo_frequency = p1["lfo"] * (1-factor) + p2["lfo"] * factor
            self.aperture_base = p1["aperture"] * (1-factor) + p2["aperture"] * factor
            self.aperture_modulation = p1.get("aperture_mod", 0) * (1-factor) + p2.get("aperture_mod", 0) * factor
            
            # Para la forma, usar el más dominante
            if factor < 0.5:
                self.modulation_shape = p1["shape"]
            else:
                self.modulation_shape = p2["shape"]
                
    def set_intensity(self, intensity: float):
        """Establecer intensidad global de la modulación (0.0 a 1.0)"""
        self.intensity = np.clip(intensity, 0.0, 1.0)
        
    def _perlin_noise(self, x: float, y: float = 0, z: float = 0) -> float:
        """Ruido Perlin simplificado para movimiento orgánico"""
        # Implementación básica de ruido
        def fade(t):
            return t * t * t * (t * (t * 6 - 15) + 10)
        
        def lerp(t, a, b):
            return a + t * (b - a)
        
        # Usar sin() como aproximación para demo
        return np.sin(x * 2.1 + self.noise_seed) * np.cos(y * 1.7) * np.sin(z * 2.3)
        
        def update(self, dt: float):
        """Actualizar posición usando arquitectura de DELTAS (suma)"""
        if dt < 0.0001:
            return
            
        # Resetear offsets
        self.concentration_offset = np.zeros(3)
        self.macro_rotation_offset = np.zeros(3)
        self.trajectory_offset = np.zeros(3)
        self.algorithmic_rotation_offset = np.zeros(3)
        
        # 1. Calcular offset de trayectoria individual (IS)
        if 'individual_trajectory' in self.components:
            traj = self.components['individual_trajectory']
            if traj.enabled:
                self.trajectory_offset = traj.get_position(self.time) - self.base_position
        
        # 2. Calcular offset de concentración
        if 'concentration' in self.components:
            conc = self.components['concentration']
            if conc.enabled and conc.factor < 0.99:
                target = conc.target_point
                current = self.get_position()
                # Interpolar hacia el punto de concentración
                concentrated = current * conc.factor + target * (1 - conc.factor)
                self.concentration_offset = concentrated - current
        
        # 3. Calcular offset de rotación del macro (MS)
        if 'macro_rotation' in self.components:
            rot = self.components['macro_rotation']
            if rot.enabled:
                # Aplicar rotación alrededor del centro del macro
                angle = rot.angle
                center = rot.center
                current = self.get_position()
                
                # Rotar alrededor del centro
                relative = current - center
                cos_a, sin_a = np.cos(angle), np.sin(angle)
                
                if rot.axis == 'yaw':  # Rotación en Z
                    rotated = np.array([
                        relative[0] * cos_a - relative[1] * sin_a,
                        relative[0] * sin_a + relative[1] * cos_a,
                        relative[2]
                    ])
                elif rot.axis == 'pitch':  # Rotación en Y
                    rotated = np.array([
                        relative[0] * cos_a + relative[2] * sin_a,
                        relative[1],
                        -relative[0] * sin_a + relative[2] * cos_a
                    ])
                else:  # roll - Rotación en X
                    rotated = np.array([
                        relative[0],
                        relative[1] * cos_a - relative[2] * sin_a,
                        relative[1] * sin_a + relative[2] * cos_a
                    ])
                
                self.macro_rotation_offset = (rotated + center) - current
        
        # 4. Calcular offset de rotación algorítmica
        if 'algorithmic_rotation' in self.components:
            algo_rot = self.components['algorithmic_rotation']
            if algo_rot.enabled:
                # Aplicar patrón de rotación
                self.algorithmic_rotation_offset = algo_rot.get_offset(self.time)
        
        # Actualizar tiempo
        self.time += dt
    
    def get_position(self) -> np.ndarray:
        """Obtener posición final sumando TODOS los componentes"""
        return (self.base_position + 
                self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
    
    def _combine_components(self) -> np.ndarray:
        """Combinar todos los offsets (método auxiliar)"""
        return (self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
class IndividualTrajectory(MotionComponent, MovementModeMixin):
    """
    Nivel 2: Trayectoria individual de cada fuente
    Define la forma (círculo, espiral, etc.)
    """
    
    def update_movement(self, dt: float) -> float:
        """Actualizar posición según el modo de movimiento"""
        if self.movement_mode == TrajectoryMovementMode.STOP:
            return self.position_on_trajectory
            
        elif self.movement_mode == TrajectoryMovementMode.FIX:
            # Movimiento normal
            self.position_on_trajectory += self.movement_speed * self.speed_factor * dt
            return self.position_on_trajectory
            
        elif self.movement_mode == TrajectoryMovementMode.RANDOM:
            # Actualizar timer
            self.random_timer += dt
            if self.random_timer >= self.random_interval:
                self.random_timer = 0.0
                self.random_target = np.random.uniform(0, 2 * np.pi)
            
            # Interpolar suavemente hacia el objetivo
            diff = self.random_target - self.position_on_trajectory
            self.position_on_trajectory += diff * (1.0 - self.random_smoothing) * dt
            return self.position_on_trajectory
            
        elif self.movement_mode == TrajectoryMovementMode.VIBRATION:
            # Movimiento base + vibración
            self.position_on_trajectory += self.movement_speed * self.speed_factor * dt
            self.vibration_phase += self.vibration_frequency * dt
            vibration = self.vibration_amplitude * np.sin(self.vibration_phase * 2 * np.pi)
            return self.position_on_trajectory + vibration
            
        elif self.movement_mode == TrajectoryMovementMode.SPIN:
            # Rotación rápida
            self.position_on_trajectory += self.spin_speed * dt
            return self.position_on_trajectory
            
        elif self.movement_mode == TrajectoryMovementMode.FREEZE:
            # Mantener posición congelada
            if self.freeze_position is None:
                self.freeze_position = self.position_on_trajectory
            return self.freeze_position
            
        return self.position_on_trajectory

    def __init__(self, source_id: Optional[int] = None):
        super().__init__("individual_trajectory")
        MovementModeMixin.__init__(self)
        self.trajectory_type = "static"
        self.radius = 1.0
        self.height = 0.0
        self.phase = 0.0
        self.speed = 1.0
        self.center = np.zeros(3)
        self.shape_type = "circle"
        self.movement_mode = TrajectoryMovementMode.FIX
        self.position_on_trajectory = 0.0
        self.movement_speed = 1.0
        self.speed_factor = 1.0  # Factor individual de velocidad (fase)
        self.initial_offset = 0.0  # Offset inicial en la trayectoria
        self.speed_factor = 1.0  # Factor individual de velocidad (fase)
        self.initial_offset = 0.0  # Offset inicial en la trayectoria
        self.vibration_frequency = 2.0
        self.vibration_amplitude = 0.1
        self.vibration_phase = 0.0
        self.random_timer = 0.0
        self.random_target = 0.0
        self.random_interval = 1.0
        self.random_smoothing = 0.8
        self.spin_speed = 10.0
        self.freeze_position = None
        
    def set_trajectory(self, traj_type: str, **params):
        """Configurar tipo y parámetros de trayectoria"""
        self.trajectory_type = traj_type
        self.radius = params.get('radius', 1.0)
        self.height = params.get('height', 0.0)
        self.speed = params.get('speed', 1.0)
        self.center = params.get('center', np.zeros(3))
        
        def update(self, dt: float):
        """Actualizar posición usando arquitectura de DELTAS (suma)"""
        if dt < 0.0001:
            return
            
        # Resetear offsets
        self.concentration_offset = np.zeros(3)
        self.macro_rotation_offset = np.zeros(3)
        self.trajectory_offset = np.zeros(3)
        self.algorithmic_rotation_offset = np.zeros(3)
        
        # 1. Calcular offset de trayectoria individual (IS)
        if 'individual_trajectory' in self.components:
            traj = self.components['individual_trajectory']
            if traj.enabled:
                self.trajectory_offset = traj.get_position(self.time) - self.base_position
        
        # 2. Calcular offset de concentración
        if 'concentration' in self.components:
            conc = self.components['concentration']
            if conc.enabled and conc.factor < 0.99:
                target = conc.target_point
                current = self.get_position()
                # Interpolar hacia el punto de concentración
                concentrated = current * conc.factor + target * (1 - conc.factor)
                self.concentration_offset = concentrated - current
        
        # 3. Calcular offset de rotación del macro (MS)
        if 'macro_rotation' in self.components:
            rot = self.components['macro_rotation']
            if rot.enabled:
                # Aplicar rotación alrededor del centro del macro
                angle = rot.angle
                center = rot.center
                current = self.get_position()
                
                # Rotar alrededor del centro
                relative = current - center
                cos_a, sin_a = np.cos(angle), np.sin(angle)
                
                if rot.axis == 'yaw':  # Rotación en Z
                    rotated = np.array([
                        relative[0] * cos_a - relative[1] * sin_a,
                        relative[0] * sin_a + relative[1] * cos_a,
                        relative[2]
                    ])
                elif rot.axis == 'pitch':  # Rotación en Y
                    rotated = np.array([
                        relative[0] * cos_a + relative[2] * sin_a,
                        relative[1],
                        -relative[0] * sin_a + relative[2] * cos_a
                    ])
                else:  # roll - Rotación en X
                    rotated = np.array([
                        relative[0],
                        relative[1] * cos_a - relative[2] * sin_a,
                        relative[1] * sin_a + relative[2] * cos_a
                    ])
                
                self.macro_rotation_offset = (rotated + center) - current
        
        # 4. Calcular offset de rotación algorítmica
        if 'algorithmic_rotation' in self.components:
            algo_rot = self.components['algorithmic_rotation']
            if algo_rot.enabled:
                # Aplicar patrón de rotación
                self.algorithmic_rotation_offset = algo_rot.get_offset(self.time)
        
        # Actualizar tiempo
        self.time += dt
    
    def get_position(self) -> np.ndarray:
        """Obtener posición final sumando TODOS los componentes"""
        return (self.base_position + 
                self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
    
    def _combine_components(self) -> np.ndarray:
        """Combinar todos los offsets (método auxiliar)"""
        return (self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
    def set_rotation(self, pitch: float = 0.0, yaw: float = 0.0, roll: float = 0.0, enabled: bool = True):
        """
        Configurar la rotación de la trayectoria individual
        
        Parameters
        ----------
        pitch : float
            Rotación alrededor del eje X (radianes)
        yaw : float
            Rotación alrededor del eje Y (radianes)
        roll : float
            Rotación alrededor del eje Z (radianes)
        enabled : bool
            Activar/desactivar la rotación
        """
        self.rotation_enabled = enabled
        self.rotation_euler = np.array([pitch, yaw, roll])
        
        # Calcular matriz de rotación
        if enabled:
            # Rotación X (pitch)
            cx, sx = np.cos(pitch), np.sin(pitch)
            rx = np.array([[1, 0, 0], [0, cx, -sx], [0, sx, cx]])
            
            # Rotación Y (yaw)
            cy, sy = np.cos(yaw), np.sin(yaw)
            ry = np.array([[cy, 0, sy], [0, 1, 0], [-sy, 0, cy]])
            
            # Rotación Z (roll)
            cz, sz = np.cos(roll), np.sin(roll)
            rz = np.array([[cz, -sz, 0], [sz, cz, 0], [0, 0, 1]])
            
            # Matriz de rotación combinada: R = Rz * Ry * Rx
            self.rotation_matrix = rz @ ry @ rx
        else:
            self.rotation_matrix = np.eye(3)

class MacroMovement(MotionComponent):
    """
    Nivel 3: Movimiento del macro completo
    Afecta al centro de masa del grupo
    """
    
    def __init__(self):
        super().__init__("macro_movement")
        self.trajectory_func: Optional[Callable[[float], np.ndarray]] = None
        self.speed = 1.0
        self.phase = 0.0
        
    def set_trajectory(self, func: Callable[[float], np.ndarray], speed: float = 1.0):
        """Establecer función de trayectoria del macro"""
        self.trajectory_func = func
        self.speed = speed
        
        def update(self, dt: float):
        """Actualizar posición usando arquitectura de DELTAS (suma)"""
        if dt < 0.0001:
            return
            
        # Resetear offsets
        self.concentration_offset = np.zeros(3)
        self.macro_rotation_offset = np.zeros(3)
        self.trajectory_offset = np.zeros(3)
        self.algorithmic_rotation_offset = np.zeros(3)
        
        # 1. Calcular offset de trayectoria individual (IS)
        if 'individual_trajectory' in self.components:
            traj = self.components['individual_trajectory']
            if traj.enabled:
                self.trajectory_offset = traj.get_position(self.time) - self.base_position
        
        # 2. Calcular offset de concentración
        if 'concentration' in self.components:
            conc = self.components['concentration']
            if conc.enabled and conc.factor < 0.99:
                target = conc.target_point
                current = self.get_position()
                # Interpolar hacia el punto de concentración
                concentrated = current * conc.factor + target * (1 - conc.factor)
                self.concentration_offset = concentrated - current
        
        # 3. Calcular offset de rotación del macro (MS)
        if 'macro_rotation' in self.components:
            rot = self.components['macro_rotation']
            if rot.enabled:
                # Aplicar rotación alrededor del centro del macro
                angle = rot.angle
                center = rot.center
                current = self.get_position()
                
                # Rotar alrededor del centro
                relative = current - center
                cos_a, sin_a = np.cos(angle), np.sin(angle)
                
                if rot.axis == 'yaw':  # Rotación en Z
                    rotated = np.array([
                        relative[0] * cos_a - relative[1] * sin_a,
                        relative[0] * sin_a + relative[1] * cos_a,
                        relative[2]
                    ])
                elif rot.axis == 'pitch':  # Rotación en Y
                    rotated = np.array([
                        relative[0] * cos_a + relative[2] * sin_a,
                        relative[1],
                        -relative[0] * sin_a + relative[2] * cos_a
                    ])
                else:  # roll - Rotación en X
                    rotated = np.array([
                        relative[0],
                        relative[1] * cos_a - relative[2] * sin_a,
                        relative[1] * sin_a + relative[2] * cos_a
                    ])
                
                self.macro_rotation_offset = (rotated + center) - current
        
        # 4. Calcular offset de rotación algorítmica
        if 'algorithmic_rotation' in self.components:
            algo_rot = self.components['algorithmic_rotation']
            if algo_rot.enabled:
                # Aplicar patrón de rotación
                self.algorithmic_rotation_offset = algo_rot.get_offset(self.time)
        
        # Actualizar tiempo
        self.time += dt
    
    def get_position(self) -> np.ndarray:
        """Obtener posición final sumando TODOS los componentes"""
        return (self.base_position + 
                self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
    
    def _combine_components(self) -> np.ndarray:
        """Combinar todos los offsets (método auxiliar)"""
        return (self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
class MacroTrajectory(MotionComponent, MovementModeMixin):
    """
    Componente para manejar la trayectoria de un macro completo
    Similar a MacroMovement pero con funcionalidad extendida
    """
    
    def __init__(self):
        super().__init__("macro_trajectory")
        MovementModeMixin.__init__(self)
        self.trajectory_func: Optional[Callable[[float], np.ndarray]] = None
        self.orientation_func: Optional[Callable[[float], np.ndarray]] = None
        self.speed = 1.0
        self.phase = 0.0
        self.last_position = np.zeros(3)
        self.last_orientation = np.zeros(3)
        
    def set_trajectory(self, 
                      position_func: Optional[Callable[[float], np.ndarray]] = None,
                      orientation_func: Optional[Callable[[float], np.ndarray]] = None,
                      speed: float = 1.0):
        """Establecer funciones de trayectoria"""
        if position_func is not None:
            self.trajectory_func = position_func
        if orientation_func is not None:
            self.orientation_func = orientation_func
        self.speed = speed
        
    def get_offset(self) -> np.ndarray:
        """Obtener el offset actual del macro"""
        return self.last_position
        
        def update(self, dt: float):
        """Actualizar posición usando arquitectura de DELTAS (suma)"""
        if dt < 0.0001:
            return
            
        # Resetear offsets
        self.concentration_offset = np.zeros(3)
        self.macro_rotation_offset = np.zeros(3)
        self.trajectory_offset = np.zeros(3)
        self.algorithmic_rotation_offset = np.zeros(3)
        
        # 1. Calcular offset de trayectoria individual (IS)
        if 'individual_trajectory' in self.components:
            traj = self.components['individual_trajectory']
            if traj.enabled:
                self.trajectory_offset = traj.get_position(self.time) - self.base_position
        
        # 2. Calcular offset de concentración
        if 'concentration' in self.components:
            conc = self.components['concentration']
            if conc.enabled and conc.factor < 0.99:
                target = conc.target_point
                current = self.get_position()
                # Interpolar hacia el punto de concentración
                concentrated = current * conc.factor + target * (1 - conc.factor)
                self.concentration_offset = concentrated - current
        
        # 3. Calcular offset de rotación del macro (MS)
        if 'macro_rotation' in self.components:
            rot = self.components['macro_rotation']
            if rot.enabled:
                # Aplicar rotación alrededor del centro del macro
                angle = rot.angle
                center = rot.center
                current = self.get_position()
                
                # Rotar alrededor del centro
                relative = current - center
                cos_a, sin_a = np.cos(angle), np.sin(angle)
                
                if rot.axis == 'yaw':  # Rotación en Z
                    rotated = np.array([
                        relative[0] * cos_a - relative[1] * sin_a,
                        relative[0] * sin_a + relative[1] * cos_a,
                        relative[2]
                    ])
                elif rot.axis == 'pitch':  # Rotación en Y
                    rotated = np.array([
                        relative[0] * cos_a + relative[2] * sin_a,
                        relative[1],
                        -relative[0] * sin_a + relative[2] * cos_a
                    ])
                else:  # roll - Rotación en X
                    rotated = np.array([
                        relative[0],
                        relative[1] * cos_a - relative[2] * sin_a,
                        relative[1] * sin_a + relative[2] * cos_a
                    ])
                
                self.macro_rotation_offset = (rotated + center) - current
        
        # 4. Calcular offset de rotación algorítmica
        if 'algorithmic_rotation' in self.components:
            algo_rot = self.components['algorithmic_rotation']
            if algo_rot.enabled:
                # Aplicar patrón de rotación
                self.algorithmic_rotation_offset = algo_rot.get_offset(self.time)
        
        # Actualizar tiempo
        self.time += dt
    
    def get_position(self) -> np.ndarray:
        """Obtener posición final sumando TODOS los componentes"""
        return (self.base_position + 
                self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
    
    def _combine_components(self) -> np.ndarray:
        """Combinar todos los offsets (método auxiliar)"""
        return (self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
class GroupBehavior(MotionComponent):
    """
    Nivel 4: Comportamiento de grupo
    Define cómo interactúan las fuentes entre sí
    """
    
    def __init__(self):
        super().__init__("group_behavior")
        self.behavior_type = "independent"
        self.cohesion = 0.5
        self.separation = 0.5
        self.alignment = 0.5
        
    def set_behavior(self, behavior_type: str, **params):
        """Configurar tipo de comportamiento grupal"""
        self.behavior_type = behavior_type
        self.cohesion = params.get('cohesion', 0.5)
        self.separation = params.get('separation', 0.5)
        self.alignment = params.get('alignment', 0.5)
        
        def update(self, dt: float):
        """Actualizar posición usando arquitectura de DELTAS (suma)"""
        if dt < 0.0001:
            return
            
        # Resetear offsets
        self.concentration_offset = np.zeros(3)
        self.macro_rotation_offset = np.zeros(3)
        self.trajectory_offset = np.zeros(3)
        self.algorithmic_rotation_offset = np.zeros(3)
        
        # 1. Calcular offset de trayectoria individual (IS)
        if 'individual_trajectory' in self.components:
            traj = self.components['individual_trajectory']
            if traj.enabled:
                self.trajectory_offset = traj.get_position(self.time) - self.base_position
        
        # 2. Calcular offset de concentración
        if 'concentration' in self.components:
            conc = self.components['concentration']
            if conc.enabled and conc.factor < 0.99:
                target = conc.target_point
                current = self.get_position()
                # Interpolar hacia el punto de concentración
                concentrated = current * conc.factor + target * (1 - conc.factor)
                self.concentration_offset = concentrated - current
        
        # 3. Calcular offset de rotación del macro (MS)
        if 'macro_rotation' in self.components:
            rot = self.components['macro_rotation']
            if rot.enabled:
                # Aplicar rotación alrededor del centro del macro
                angle = rot.angle
                center = rot.center
                current = self.get_position()
                
                # Rotar alrededor del centro
                relative = current - center
                cos_a, sin_a = np.cos(angle), np.sin(angle)
                
                if rot.axis == 'yaw':  # Rotación en Z
                    rotated = np.array([
                        relative[0] * cos_a - relative[1] * sin_a,
                        relative[0] * sin_a + relative[1] * cos_a,
                        relative[2]
                    ])
                elif rot.axis == 'pitch':  # Rotación en Y
                    rotated = np.array([
                        relative[0] * cos_a + relative[2] * sin_a,
                        relative[1],
                        -relative[0] * sin_a + relative[2] * cos_a
                    ])
                else:  # roll - Rotación en X
                    rotated = np.array([
                        relative[0],
                        relative[1] * cos_a - relative[2] * sin_a,
                        relative[1] * sin_a + relative[2] * cos_a
                    ])
                
                self.macro_rotation_offset = (rotated + center) - current
        
        # 4. Calcular offset de rotación algorítmica
        if 'algorithmic_rotation' in self.components:
            algo_rot = self.components['algorithmic_rotation']
            if algo_rot.enabled:
                # Aplicar patrón de rotación
                self.algorithmic_rotation_offset = algo_rot.get_offset(self.time)
        
        # Actualizar tiempo
        self.time += dt
    
    def get_position(self) -> np.ndarray:
        """Obtener posición final sumando TODOS los componentes"""
        return (self.base_position + 
                self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
    
    def _combine_components(self) -> np.ndarray:
        """Combinar todos los offsets (método auxiliar)"""
        return (self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
class EnvironmentalForces(MotionComponent):
    """
    Nivel 5: Fuerzas ambientales
    Viento, gravedad, atractores, etc.
    """
    
    def __init__(self):
        super().__init__("environmental_forces")
        self.forces = []
        
    def add_force(self, force_type: str, **params):
        """Añadir una fuerza ambiental"""
        force = {
            'type': force_type,
            'params': params,
            'enabled': True
        }
        self.forces.append(force)
        return len(self.forces) - 1
        
    def remove_force(self, index: int):
        """Eliminar una fuerza"""
        if 0 <= index < len(self.forces):
            self.forces.pop(index)
            
        def update(self, dt: float):
        """Actualizar posición usando arquitectura de DELTAS (suma)"""
        if dt < 0.0001:
            return
            
        # Resetear offsets
        self.concentration_offset = np.zeros(3)
        self.macro_rotation_offset = np.zeros(3)
        self.trajectory_offset = np.zeros(3)
        self.algorithmic_rotation_offset = np.zeros(3)
        
        # 1. Calcular offset de trayectoria individual (IS)
        if 'individual_trajectory' in self.components:
            traj = self.components['individual_trajectory']
            if traj.enabled:
                self.trajectory_offset = traj.get_position(self.time) - self.base_position
        
        # 2. Calcular offset de concentración
        if 'concentration' in self.components:
            conc = self.components['concentration']
            if conc.enabled and conc.factor < 0.99:
                target = conc.target_point
                current = self.get_position()
                # Interpolar hacia el punto de concentración
                concentrated = current * conc.factor + target * (1 - conc.factor)
                self.concentration_offset = concentrated - current
        
        # 3. Calcular offset de rotación del macro (MS)
        if 'macro_rotation' in self.components:
            rot = self.components['macro_rotation']
            if rot.enabled:
                # Aplicar rotación alrededor del centro del macro
                angle = rot.angle
                center = rot.center
                current = self.get_position()
                
                # Rotar alrededor del centro
                relative = current - center
                cos_a, sin_a = np.cos(angle), np.sin(angle)
                
                if rot.axis == 'yaw':  # Rotación en Z
                    rotated = np.array([
                        relative[0] * cos_a - relative[1] * sin_a,
                        relative[0] * sin_a + relative[1] * cos_a,
                        relative[2]
                    ])
                elif rot.axis == 'pitch':  # Rotación en Y
                    rotated = np.array([
                        relative[0] * cos_a + relative[2] * sin_a,
                        relative[1],
                        -relative[0] * sin_a + relative[2] * cos_a
                    ])
                else:  # roll - Rotación en X
                    rotated = np.array([
                        relative[0],
                        relative[1] * cos_a - relative[2] * sin_a,
                        relative[1] * sin_a + relative[2] * cos_a
                    ])
                
                self.macro_rotation_offset = (rotated + center) - current
        
        # 4. Calcular offset de rotación algorítmica
        if 'algorithmic_rotation' in self.components:
            algo_rot = self.components['algorithmic_rotation']
            if algo_rot.enabled:
                # Aplicar patrón de rotación
                self.algorithmic_rotation_offset = algo_rot.get_offset(self.time)
        
        # Actualizar tiempo
        self.time += dt
    
    def get_position(self) -> np.ndarray:
        """Obtener posición final sumando TODOS los componentes"""
        return (self.base_position + 
                self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
    
    def _combine_components(self) -> np.ndarray:
        """Combinar todos los offsets (método auxiliar)"""
        return (self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
class TrajectoryDisplacementMode(Enum):
    """Modos de desplazamiento de trayectoria"""
    RELATIVE = "relative"
    ABSOLUTE = "absolute"

class TrajectoryTransform(MotionComponent):
    """Transformación de trayectoria para offset y desplazamiento"""
    
    def __init__(self):
        super().__init__("trajectory_transform")
        self.displacement_mode = TrajectoryDisplacementMode.RELATIVE
        self.offset = np.zeros(3)
        self.macro_reference = np.zeros(3)
        self.macro_velocity = np.zeros(3)
        
    def set_offset(self, offset):
        """Establecer offset (puede ser array o función)"""
        self.offset = offset
        
        def update(self, dt: float):
        """Actualizar posición usando arquitectura de DELTAS (suma)"""
        if dt < 0.0001:
            return
            
        # Resetear offsets
        self.concentration_offset = np.zeros(3)
        self.macro_rotation_offset = np.zeros(3)
        self.trajectory_offset = np.zeros(3)
        self.algorithmic_rotation_offset = np.zeros(3)
        
        # 1. Calcular offset de trayectoria individual (IS)
        if 'individual_trajectory' in self.components:
            traj = self.components['individual_trajectory']
            if traj.enabled:
                self.trajectory_offset = traj.get_position(self.time) - self.base_position
        
        # 2. Calcular offset de concentración
        if 'concentration' in self.components:
            conc = self.components['concentration']
            if conc.enabled and conc.factor < 0.99:
                target = conc.target_point
                current = self.get_position()
                # Interpolar hacia el punto de concentración
                concentrated = current * conc.factor + target * (1 - conc.factor)
                self.concentration_offset = concentrated - current
        
        # 3. Calcular offset de rotación del macro (MS)
        if 'macro_rotation' in self.components:
            rot = self.components['macro_rotation']
            if rot.enabled:
                # Aplicar rotación alrededor del centro del macro
                angle = rot.angle
                center = rot.center
                current = self.get_position()
                
                # Rotar alrededor del centro
                relative = current - center
                cos_a, sin_a = np.cos(angle), np.sin(angle)
                
                if rot.axis == 'yaw':  # Rotación en Z
                    rotated = np.array([
                        relative[0] * cos_a - relative[1] * sin_a,
                        relative[0] * sin_a + relative[1] * cos_a,
                        relative[2]
                    ])
                elif rot.axis == 'pitch':  # Rotación en Y
                    rotated = np.array([
                        relative[0] * cos_a + relative[2] * sin_a,
                        relative[1],
                        -relative[0] * sin_a + relative[2] * cos_a
                    ])
                else:  # roll - Rotación en X
                    rotated = np.array([
                        relative[0],
                        relative[1] * cos_a - relative[2] * sin_a,
                        relative[1] * sin_a + relative[2] * cos_a
                    ])
                
                self.macro_rotation_offset = (rotated + center) - current
        
        # 4. Calcular offset de rotación algorítmica
        if 'algorithmic_rotation' in self.components:
            algo_rot = self.components['algorithmic_rotation']
            if algo_rot.enabled:
                # Aplicar patrón de rotación
                self.algorithmic_rotation_offset = algo_rot.get_offset(self.time)
        
        # Actualizar tiempo
        self.time += dt
    
    def get_position(self) -> np.ndarray:
        """Obtener posición final sumando TODOS los componentes"""
        return (self.base_position + 
                self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
    
    def _combine_components(self) -> np.ndarray:
        """Combinar todos los offsets (método auxiliar)"""
        return (self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
class SourceMotion:
    """
    Contenedor principal para todos los componentes de movimiento de una fuente
    """
    
    def __init__(self, source_id: int):
        self.id = source_id
        self.state = MotionState()
        
        # Componentes de movimiento
        self.components = {
            'orientation_modulation': OrientationModulation(),
            'individual_trajectory': IndividualTrajectory(),
            'trajectory_transform': TrajectoryTransform(),
            'macro_trajectory': MacroMovement(),
            'group_behavior': GroupBehavior(),
            'environmental_forces': EnvironmentalForces(),
            'concentration': ConcentrationComponent(),
        }
        
        # Estado de referencia para macros
        self.macro_reference = np.zeros(3)
        self.macro_velocity = np.zeros(3)
        
    
        def update(self, dt: float):
        """Actualizar posición usando arquitectura de DELTAS (suma)"""
        if dt < 0.0001:
            return
            
        # Resetear offsets
        self.concentration_offset = np.zeros(3)
        self.macro_rotation_offset = np.zeros(3)
        self.trajectory_offset = np.zeros(3)
        self.algorithmic_rotation_offset = np.zeros(3)
        
        # 1. Calcular offset de trayectoria individual (IS)
        if 'individual_trajectory' in self.components:
            traj = self.components['individual_trajectory']
            if traj.enabled:
                self.trajectory_offset = traj.get_position(self.time) - self.base_position
        
        # 2. Calcular offset de concentración
        if 'concentration' in self.components:
            conc = self.components['concentration']
            if conc.enabled and conc.factor < 0.99:
                target = conc.target_point
                current = self.get_position()
                # Interpolar hacia el punto de concentración
                concentrated = current * conc.factor + target * (1 - conc.factor)
                self.concentration_offset = concentrated - current
        
        # 3. Calcular offset de rotación del macro (MS)
        if 'macro_rotation' in self.components:
            rot = self.components['macro_rotation']
            if rot.enabled:
                # Aplicar rotación alrededor del centro del macro
                angle = rot.angle
                center = rot.center
                current = self.get_position()
                
                # Rotar alrededor del centro
                relative = current - center
                cos_a, sin_a = np.cos(angle), np.sin(angle)
                
                if rot.axis == 'yaw':  # Rotación en Z
                    rotated = np.array([
                        relative[0] * cos_a - relative[1] * sin_a,
                        relative[0] * sin_a + relative[1] * cos_a,
                        relative[2]
                    ])
                elif rot.axis == 'pitch':  # Rotación en Y
                    rotated = np.array([
                        relative[0] * cos_a + relative[2] * sin_a,
                        relative[1],
                        -relative[0] * sin_a + relative[2] * cos_a
                    ])
                else:  # roll - Rotación en X
                    rotated = np.array([
                        relative[0],
                        relative[1] * cos_a - relative[2] * sin_a,
                        relative[1] * sin_a + relative[2] * cos_a
                    ])
                
                self.macro_rotation_offset = (rotated + center) - current
        
        # 4. Calcular offset de rotación algorítmica
        if 'algorithmic_rotation' in self.components:
            algo_rot = self.components['algorithmic_rotation']
            if algo_rot.enabled:
                # Aplicar patrón de rotación
                self.algorithmic_rotation_offset = algo_rot.get_offset(self.time)
        
        # Actualizar tiempo
        self.time += dt
    
    def get_position(self) -> np.ndarray:
        """Obtener posición final sumando TODOS los componentes"""
        return (self.base_position + 
                self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
    
    def _combine_components(self) -> np.ndarray:
        """Combinar todos los offsets (método auxiliar)"""
        return (self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
class ConcentrationComponent(MotionComponent):
    """
    Componente que maneja la concentración/dispersión de fuentes
    Se aplica como último paso después de todos los demás movimientos
    """
    
    def __init__(self):
        super().__init__("concentration")
        
        # Parámetros principales
        self.factor = 1.0  # 0=concentrado, 1=disperso
        self.target_point = np.zeros(3)
        self.mode = ConcentrationMode.FIXED_POINT
        
        # Control de animación
        self.animation_active = False
        self.animation_start_factor = 1.0
        self.animation_target_factor = 0.0
        self.animation_duration = 2.0
        self.animation_elapsed = 0.0
        self.animation_curve = ConcentrationCurve.EASE_IN_OUT
        
        # Parámetros avanzados
        self.include_macro_trajectory = True
        self.attenuate_rotations = True
        self.attenuate_modulations = True
        self.concentration_order = "uniform"
        
        # Cache
        self._macro_center = np.zeros(3)
        self._source_distances = {}
        
        def update(self, dt: float):
        """Actualizar posición usando arquitectura de DELTAS (suma)"""
        if dt < 0.0001:
            return
            
        # Resetear offsets
        self.concentration_offset = np.zeros(3)
        self.macro_rotation_offset = np.zeros(3)
        self.trajectory_offset = np.zeros(3)
        self.algorithmic_rotation_offset = np.zeros(3)
        
        # 1. Calcular offset de trayectoria individual (IS)
        if 'individual_trajectory' in self.components:
            traj = self.components['individual_trajectory']
            if traj.enabled:
                self.trajectory_offset = traj.get_position(self.time) - self.base_position
        
        # 2. Calcular offset de concentración
        if 'concentration' in self.components:
            conc = self.components['concentration']
            if conc.enabled and conc.factor < 0.99:
                target = conc.target_point
                current = self.get_position()
                # Interpolar hacia el punto de concentración
                concentrated = current * conc.factor + target * (1 - conc.factor)
                self.concentration_offset = concentrated - current
        
        # 3. Calcular offset de rotación del macro (MS)
        if 'macro_rotation' in self.components:
            rot = self.components['macro_rotation']
            if rot.enabled:
                # Aplicar rotación alrededor del centro del macro
                angle = rot.angle
                center = rot.center
                current = self.get_position()
                
                # Rotar alrededor del centro
                relative = current - center
                cos_a, sin_a = np.cos(angle), np.sin(angle)
                
                if rot.axis == 'yaw':  # Rotación en Z
                    rotated = np.array([
                        relative[0] * cos_a - relative[1] * sin_a,
                        relative[0] * sin_a + relative[1] * cos_a,
                        relative[2]
                    ])
                elif rot.axis == 'pitch':  # Rotación en Y
                    rotated = np.array([
                        relative[0] * cos_a + relative[2] * sin_a,
                        relative[1],
                        -relative[0] * sin_a + relative[2] * cos_a
                    ])
                else:  # roll - Rotación en X
                    rotated = np.array([
                        relative[0],
                        relative[1] * cos_a - relative[2] * sin_a,
                        relative[1] * sin_a + relative[2] * cos_a
                    ])
                
                self.macro_rotation_offset = (rotated + center) - current
        
        # 4. Calcular offset de rotación algorítmica
        if 'algorithmic_rotation' in self.components:
            algo_rot = self.components['algorithmic_rotation']
            if algo_rot.enabled:
                # Aplicar patrón de rotación
                self.algorithmic_rotation_offset = algo_rot.get_offset(self.time)
        
        # Actualizar tiempo
        self.time += dt
    
    def get_position(self) -> np.ndarray:
        """Obtener posición final sumando TODOS los componentes"""
        return (self.base_position + 
                self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)
    
    def _combine_components(self) -> np.ndarray:
        """Combinar todos los offsets (método auxiliar)"""
        return (self.trajectory_offset + 
                self.concentration_offset + 
                self.macro_rotation_offset +
                self.algorithmic_rotation_offset)