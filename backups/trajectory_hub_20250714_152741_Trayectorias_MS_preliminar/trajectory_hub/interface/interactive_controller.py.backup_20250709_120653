"""
Interactive Controller - Interfaz CLI simplificada
Versi√≥n 2.0 - Arquitectura Orquestador
"""
import logging
from typing import Optional, Dict, Any
from ..control import CommandProcessor, SemanticCommand, IntentType, CLIInterface
from ..core.enhanced_trajectory_engine import EnhancedTrajectoryEngine
from ..core.spat_osc_bridge import SpatOSCBridge, OSCTarget


logger = logging.getLogger(__name__)


class InteractiveController:
    """
    Controlador interactivo simplificado.
    Solo maneja navegaci√≥n de men√∫s y delega toda la l√≥gica al CommandProcessor.
    """
    
    def __init__(self, engine: EnhancedTrajectoryEngine):
        self.engine = engine
        self.command_processor = CommandProcessor(engine)
        self.ui = CLIInterface()
        self.current_menu = "main"
        self.selected_macro = None
        
        # Estado de sesi√≥n
        self.session_active = True
        self.command_history = []
        
        logger.info("InteractiveController v2.0 inicializado")
    
    # ========== NAVEGACI√ìN PRINCIPAL ==========
    
    def run(self):
        """Loop principal del controlador"""
        self.ui.clear_screen()
        self.ui.show_header("TRAJECTORY HUB - Control Interactivo v2.0")
        
        while self.session_active:
            try:
                self._show_current_menu()
                choice = self.ui.get_input().lower()
                
                if choice == 'q':
                    if self._confirm_exit():
                        break
                elif choice == 'b':
                    self._navigate_back()
                else:
                    self._process_choice(choice)
                    
            except KeyboardInterrupt:
                if self._confirm_exit():
                    break
            except Exception as e:
                logger.error(f"Error en loop principal: {e}")
                self.ui.show_error(f"Error inesperado: {str(e)}")
    
    def _show_current_menu(self):
        """Muestra el men√∫ actual"""
        menu_handlers = {
            "main": self._show_main_menu,
            "movement": self._show_movement_menu,
            "delta": self._show_delta_menu,
            "modulation": self._show_modulation_menu,
            "presets": self._show_presets_menu,
            "system": self._show_system_menu
        }
        
        if self.current_menu in menu_handlers:
            menu_handlers[self.current_menu]()
        else:
            self.ui.show_error(f"Men√∫ desconocido: {self.current_menu}")
            self.current_menu = "main"
    
    def _navigate_back(self):
        """Navega al men√∫ anterior"""
        nav_map = {
            "movement": "main",
            "delta": "main",
            "modulation": "main",
            "presets": "main",
            "system": "main"
        }
        self.current_menu = nav_map.get(self.current_menu, "main")
    
    def _process_choice(self, choice: str):
        """Procesa la elecci√≥n del usuario seg√∫n el men√∫ actual"""
        processors = {
            "main": self._process_main_choice,
            "movement": self._process_movement_choice,
            "delta": self._process_delta_choice,
            "modulation": self._process_modulation_choice,
            "presets": self._process_presets_choice,
            "system": self._process_system_choice
        }
        
        if self.current_menu in processors:
            processors[self.current_menu](choice)
    
    # ========== MEN√öS ==========
    
    def _show_main_menu(self):
        """Men√∫ principal"""
        options = [
            ("1", "üéØ Crear Macro/Grupo"),
            ("2", "üåÄ Sistema de Movimiento (Deltas)"),
            ("3", "üéµ Modulador 3D"),
            ("4", "üé® Presets Art√≠sticos"),
            ("5", "‚ÑπÔ∏è  Sistema e Informaci√≥n"),
            ("-", ""),
            ("q", "Salir")
        ]
        
        self.ui.show_menu("MEN√ö PRINCIPAL", options)
        
        if self.selected_macro:
            self.ui.show_info(f"Macro activo: {self.selected_macro}")
    
    def _show_movement_menu(self):
        """Men√∫ del sistema de movimiento"""
        options = [
            ("1", "üìç Concentraci√≥n/Dispersi√≥n"),
            ("2", "üîÑ Trayectorias Macro"),
            ("3", "üéØ Trayectorias Individuales"),
            ("4", "üåÄ Rotaciones Macro"),
            ("5", "üî∏ Rotaciones Individuales"),
            ("6", "üèÉ Modos de Movimiento"),
            ("-", ""),
            ("b", "Volver"),
            ("q", "Salir")
        ]
        
        self.ui.show_menu("SISTEMA DE MOVIMIENTO", options)
    
    def _show_delta_menu(self):
        """Men√∫ espec√≠fico del sistema de deltas"""
        options = [
            ("== COMPONENTES DELTA ==", ""),
            ("1", "ConcentrationComponent - Agrupar/Dispersar"),
            ("2", "MacroTrajectory - Trayectorias de grupo"),
            ("3", "IndividualTrajectory - Trayectorias por fuente"),
            ("4", "MacroRotation - Rotaci√≥n algor√≠tmica de grupo"),
            ("5", "ManualMacroRotation - Rotaci√≥n manual de grupo"),
            ("6", "IndividualRotation - Rotaci√≥n algor√≠tmica individual"),
            ("7", "ManualIndividualRotation - Rotaci√≥n manual individual"),
            ("-", ""),
            ("b", "Volver"),
            ("q", "Salir")
        ]
        
        self.ui.show_menu("SISTEMA DE DELTAS", options)
    
    def _show_modulation_menu(self):
        """Men√∫ del modulador 3D"""
        options = [
            ("1", "üé≠ Aplicar Preset de Modulaci√≥n"),
            ("2", "üéöÔ∏è Ajustar Intensidad Global"),
            ("3", "‚ö° Configurar Velocidad (LFO)"),
            ("4", "üîÄ Interpolar entre Presets"),
            ("5", "üõë Desactivar Modulaci√≥n"),
            ("-", ""),
            ("b", "Volver"),
            ("q", "Salir")
        ]
        
        self.ui.show_menu("MODULADOR 3D", options)
    
    def _show_presets_menu(self):
        """Men√∫ de presets art√≠sticos"""
        options = [
            ("1", "üåå Galaxia Rotante"),
            ("2", "üåä Oc√©ano Respirante"),
            ("3", "‚ö° Enjambre Nervioso"),
            ("4", "üåÄ V√≥rtice Hipn√≥tico"),
            ("5", "üé≠ Composici√≥n Aleatoria"),
            ("-", ""),
            ("b", "Volver"),
            ("q", "Salir")
        ]
        
        self.ui.show_menu("PRESETS ART√çSTICOS", options)
    
    def _show_system_menu(self):
        """Men√∫ de sistema e informaci√≥n"""
        options = [
            ("1", "üìä Estado del Sistema"),
            ("2", "üìã Listar Macros Activos"),
            ("3", "üîç Informaci√≥n de Macro"),
            ("4", "üì° Estado OSC"),
            ("5", "üíæ Guardar Configuraci√≥n"),
            ("6", "üìÇ Cargar Configuraci√≥n"),
            ("-", ""),
            ("b", "Volver"),
            ("q", "Salir")
        ]
        
        self.ui.show_menu("SISTEMA E INFORMACI√ìN", options)
    
    # ========== PROCESADORES DE OPCIONES ==========
    
    def _process_main_choice(self, choice: str):
        """Procesa opciones del men√∫ principal"""
        if choice == "1":
            self._create_macro_wizard()
        elif choice == "2":
            self.current_menu = "delta"
        elif choice == "3":
            self.current_menu = "modulation"
        elif choice == "4":
            self.current_menu = "presets"
        elif choice == "5":
            self.current_menu = "system"
    
    def _process_movement_choice(self, choice: str):
        """Procesa opciones del men√∫ de movimiento"""
        if not self._ensure_macro_selected():
            return
            
        commands = {
            "1": self._create_concentration_command,
            "2": self._create_macro_trajectory_command,
            "3": self._create_individual_trajectory_command,
            "4": self._create_macro_rotation_command,
            "5": self._create_individual_rotation_command,
            "6": self._configure_movement_modes
        }
        
        if choice in commands:
            command = commands[choice]()
            if command:
                self._execute_command(command)
    
    def _process_delta_choice(self, choice: str):
        """Procesa opciones del men√∫ delta"""
        # Redirige a las funciones espec√≠ficas del men√∫ movement
        self.current_menu = "movement"
        mapping = {
            "1": "1",  # Concentration
            "2": "2",  # MacroTrajectory
            "3": "3",  # IndividualTrajectory
            "4": "4",  # MacroRotation
            "5": "4",  # ManualMacroRotation (mismo men√∫)
            "6": "5",  # IndividualRotation
            "7": "5"   # ManualIndividualRotation (mismo men√∫)
        }
        if choice in mapping:
            self._process_movement_choice(mapping[choice])
    
    def _process_modulation_choice(self, choice: str):
        """Procesa opciones del men√∫ de modulaci√≥n"""
        if not self._ensure_macro_selected():
            return
            
        if choice == "1":
            self._apply_modulation_preset()
        elif choice == "2":
            self._adjust_modulation_intensity()
        elif choice == "3":
            self._configure_modulation_lfo()
        elif choice == "4":
            self._interpolate_modulation_presets()
        elif choice == "5":
            self._toggle_modulation()
    
    def _process_presets_choice(self, choice: str):
        """Procesa opciones del men√∫ de presets"""
        preset_map = {
            "1": "rotating_galaxy",
            "2": "breathing_ocean",
            "3": "nervous_swarm",
            "4": "hypnotic_vortex",
            "5": "random_composition"
        }
        
        if choice in preset_map:
            command = SemanticCommand(
                intent=IntentType.LOAD_PRESET,
                parameters={"preset_name": preset_map[choice]},
                source="interactive_cli"
            )
            self._execute_command(command)
    
    def _process_system_choice(self, choice: str):
        """Procesa opciones del men√∫ de sistema"""
        if choice == "1":
            self._show_system_status()
        elif choice == "2":
            self._list_active_macros()
        elif choice == "3":
            self._show_macro_info()
        elif choice == "4":
            self._show_osc_status()
        elif choice == "5":
            self._save_configuration()
        elif choice == "6":
            self._load_configuration()
    
    # ========== WIZARDS DE CREACI√ìN ==========
    
    def _create_macro_wizard(self):
        """Wizard para crear un macro"""
        config = self.ui.get_macro_config()
        if not config:
            return
            
        command = SemanticCommand(
            intent=IntentType.CREATE_MACRO,
            parameters=config,
            source="interactive_cli"
        )
        
        result = self._execute_command(command)
        if result.success:
            self.selected_macro = config["name"]
            self.ui.show_success(f"Macro '{config['name']}' seleccionado")
    
    def _create_concentration_command(self) -> Optional[SemanticCommand]:
        """Crea comando de concentraci√≥n"""
        factor = self.ui.get_numeric_input(
            "Factor de concentraci√≥n (0=disperso, 1=concentrado): ",
            0.0, 1.0
        )
        
        if factor is None:
            return None
            
        return SemanticCommand(
            intent=IntentType.APPLY_CONCENTRATION,
            parameters={
                "target": self.selected_macro,
                "factor": factor
            },
            source="interactive_cli"
        )
    
    def _create_macro_trajectory_command(self) -> Optional[SemanticCommand]:
        """Crea comando de trayectoria macro"""
        config = self.ui.get_movement_config()
        if not config:
            return None
            
        return SemanticCommand(
            intent=IntentType.SET_TRAJECTORY,
            parameters={
                "target": self.selected_macro,
                "trajectory_type": config["trajectory_type"],
                "trajectory_params": {"speed": config["speed"]}
            },
            source="interactive_cli"
        )
    
    def _create_individual_trajectory_command(self) -> Optional[SemanticCommand]:
        """Crea comando de trayectorias individuales"""
        self.ui.show_info("Configuraci√≥n de trayectorias individuales")
        
        modes = [
            "Todas iguales",
            "Formas mixtas",
            "Velocidades diferentes",
            "Configuraci√≥n completa"
        ]
        
        mode_idx = self.ui.get_choice_from_list(modes, "Modo de configuraci√≥n:")
        if mode_idx is None:
            return None
            
        # Simplificado por ahora
        return SemanticCommand(
            intent=IntentType.SET_INDIVIDUAL_MOVEMENT,
            parameters={
                "target": self.selected_macro,
                "mode": modes[mode_idx],
                "config": {}  # TODO: Expandir seg√∫n modo
            },
            source="interactive_cli"
        )
    
    def _create_macro_rotation_command(self) -> Optional[SemanticCommand]:
        """Crea comando de rotaci√≥n macro"""
        self.ui.show_info("Configuraci√≥n de rotaci√≥n de macro")
        
        rotation_type = self.ui.get_choice_from_list(
            ["Algor√≠tmica (continua)", "Manual (posici√≥n espec√≠fica)"],
            "Tipo de rotaci√≥n:"
        )
        
        if rotation_type is None:
            return None
            
        if rotation_type == 0:  # Algor√≠tmica
            speed_x = self.ui.get_numeric_input("Velocidad X (rad/s): ", -5, 5) or 0
            speed_y = self.ui.get_numeric_input("Velocidad Y (rad/s): ", -5, 5) or 0
            speed_z = self.ui.get_numeric_input("Velocidad Z (rad/s): ", -5, 5) or 0
            
            return SemanticCommand(
                intent=IntentType.APPLY_ROTATION,
                parameters={
                    "target": self.selected_macro,
                    "rotation_params": {
                        "type": "algorithmic",
                        "speed_x": speed_x,
                        "speed_y": speed_y,
                        "speed_z": speed_z
                    }
                },
                source="interactive_cli"
            )
        else:  # Manual
            yaw = self.ui.get_numeric_input("Yaw (grados): ", -180, 180) or 0
            pitch = self.ui.get_numeric_input("Pitch (grados): ", -90, 90) or 0
            roll = self.ui.get_numeric_input("Roll (grados): ", -180, 180) or 0
            speed = self.ui.get_numeric_input("Velocidad interpolaci√≥n (0.1-1): ", 0.1, 1) or 0.5
            
            import math
            return SemanticCommand(
                intent=IntentType.APPLY_ROTATION,
                parameters={
                    "target": self.selected_macro,
                    "rotation_params": {
                        "type": "manual",
                        "yaw": math.radians(yaw),
                        "pitch": math.radians(pitch),
                        "roll": math.radians(roll),
                        "speed": speed
                    }
                },
                source="interactive_cli"
            )
    
    def _create_individual_rotation_command(self) -> Optional[SemanticCommand]:
        """Crea comando de rotaci√≥n individual"""
        # TODO: Implementar similar a macro rotation pero para fuentes individuales
        self.ui.show_warning("Rotaci√≥n individual en desarrollo")
        return None
    
    def _configure_movement_modes(self):
        """Configura modos de movimiento"""
        self.ui.show_info("Modos de movimiento")
        modes = ["stop", "fix", "random", "vibration", "spin"]
        mode_idx = self.ui.get_choice_from_list(modes, "Seleccione modo:")
        
        if mode_idx is not None:
            self.ui.show_success(f"Modo '{modes[mode_idx]}' aplicado")
            # TODO: Implementar comando real
    
    # ========== MODULACI√ìN 3D ==========
    
    def _apply_modulation_preset(self):
        """Aplica preset de modulaci√≥n"""
        presets = [
            "respiraci√≥n_suave",
            "nervioso_aleatorio",
            "espiral_c√≥smica",
            "lissajous_complejo",
            "p√©ndulo_hipn√≥tico"
        ]
        
        preset_idx = self.ui.get_choice_from_list(presets, "Seleccione preset:")
        if preset_idx is None:
            return
            
        command = SemanticCommand(
            intent=IntentType.APPLY_MODULATION,
            parameters={
                "target": self.selected_macro,
                "preset": presets[preset_idx]
            },
            source="interactive_cli"
        )
        
        self._execute_command(command)
    
    def _adjust_modulation_intensity(self):
        """Ajusta intensidad de modulaci√≥n"""
        intensity = self.ui.get_numeric_input(
            "Intensidad (0-100%): ", 0, 100
        )
        
        if intensity is not None:
            command = SemanticCommand(
                intent=IntentType.SET_MODULATION_INTENSITY,
                parameters={
                    "target": self.selected_macro,
                    "intensity": intensity / 100.0
                },
                source="interactive_cli"
            )
            self._execute_command(command)
    
    def _configure_modulation_lfo(self):
        """Configura LFO de modulaci√≥n"""
        lfo = self.ui.get_numeric_input(
            "Frecuencia LFO (Hz): ", 0.1, 10
        )
        
        if lfo is not None:
            # TODO: Crear comando apropiado
            self.ui.show_success(f"LFO configurado a {lfo} Hz")
    
    def _interpolate_modulation_presets(self):
        """Interpola entre presets de modulaci√≥n"""
        self.ui.show_warning("Interpolaci√≥n de presets en desarrollo")
    
    def _toggle_modulation(self):
        """Activa/desactiva modulaci√≥n"""
        # TODO: Implementar toggle real
        self.ui.show_success("Modulaci√≥n toggle")
    
    # ========== UTILIDADES ==========
    
    def _execute_command(self, command: SemanticCommand) -> Any:
        """Ejecuta un comando y muestra el resultado"""
        self.command_history.append(command)
        
        result = self.command_processor.execute(command)
        
        if result.success:
            self.ui.show_success(result.message)
        else:
            self.ui.show_error(result.message)
            if result.error:
                logger.error(f"Error detalle: {result.error}")
                
        return result
    
    def _ensure_macro_selected(self) -> bool:
        """Verifica que haya un macro seleccionado"""
        if not self.selected_macro:
            self.ui.show_warning("Primero debe crear o seleccionar un macro")
            
            # Ofrecer crear uno r√°pido
            if self.ui.get_yes_no("¬øDesea crear un macro ahora?"):
                self._create_macro_wizard()
                
        return self.selected_macro is not None
    
    def _confirm_exit(self) -> bool:
        """Confirma salida del programa"""
        return self.ui.get_yes_no("¬øEst√° seguro que desea salir?")
    
    # ========== INFORMACI√ìN DEL SISTEMA ==========
    
    def _show_system_status(self):
        """Muestra estado del sistema"""
        self.ui.show_header("ESTADO DEL SISTEMA")
        
        info = [
            f"Motor: {self.engine.__class__.__name__}",
            f"Fuentes m√°ximas: {self.engine.max_sources}",
            f"FPS objetivo: {self.engine.fps}",
            f"Macros activos: {len(self.engine._macros)}",
            f"Sistema de deltas: ‚úÖ Activo",
            f"Modulador 3D: {'‚úÖ Activo' if hasattr(self.engine, 'enable_modulator') else '‚ùå Inactivo'}"
        ]
        
        for line in info:
            print(f"  {line}")
            
        self.ui.pause()
    
    def _list_active_macros(self):
        """Lista macros activos"""
        self.ui.show_header("MACROS ACTIVOS")
        
        if not self.engine._macros:
            self.ui.show_info("No hay macros activos")
        else:
            for name, macro in self.engine._macros.items():
                status = "‚úÖ Seleccionado" if name == self.selected_macro else ""
                print(f"  ‚Ä¢ {name} ({len(macro.source_ids)} fuentes) {status}")
                
        self.ui.pause()
    
    def _show_macro_info(self):
        """Muestra informaci√≥n detallada de un macro"""
        if not self._ensure_macro_selected():
            return
            
        # TODO: Implementar informaci√≥n detallada
        self.ui.show_info(f"Informaci√≥n de '{self.selected_macro}'")
        self.ui.pause()
    
    def _show_osc_status(self):
        """Muestra estado de conexi√≥n OSC"""
        self.ui.show_header("ESTADO OSC")
        
        if hasattr(self.engine, 'osc_bridge'):
            stats = self.engine.osc_bridge.get_stats()
            print(f"  Destinos activos: {stats.get('active_targets', 0)}")
            print(f"  Mensajes enviados: {stats.get('messages_sent', 0)}")
            print(f"  Tasa de mensajes: {stats.get('message_rate', 0):.1f} msg/s")
        else:
            self.ui.show_warning("Bridge OSC no disponible")
            
        self.ui.pause()
    
    def _save_configuration(self):
        """Guarda configuraci√≥n actual"""
        # TODO: Implementar guardado real
        self.ui.show_warning("Guardado de configuraci√≥n en desarrollo")
    
    def _load_configuration(self):
        """Carga configuraci√≥n guardada"""
        # TODO: Implementar carga real
        self.ui.show_warning("Carga de configuraci√≥n en desarrollo")


# ========== PUNTO DE ENTRADA ==========

def main():
    """Punto de entrada principal"""
    import sys
    import os
    
    # A√±adir path del proyecto
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    
    from trajectory_hub.core.enhanced_trajectory_engine import EnhancedTrajectoryEngine
    from trajectory_hub.core.spat_osc_bridge import OSCTarget
    
    # Configurar logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Crear engine
    print("üöÄ Inicializando Trajectory Hub...")
    engine = EnhancedTrajectoryEngine(
        max_sources=100,
        fps=60,
        enable_modulator=True
    )
    
    # Configurar OSC
    target = OSCTarget(host="127.0.0.1", port=9000, name="Spat_Local")
    engine.osc_bridge.add_target(target)
    
    # Crear y ejecutar controlador
    controller = InteractiveController(engine)
    controller.run()
    
    print("\nüëã ¬°Hasta luego!")


if __name__ == "__main__":
    main()
