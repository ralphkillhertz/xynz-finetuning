"""
interactive_controller.py - Controlador principal del sistema interactivo (CORREGIDO)
"""
import asyncio
import numpy as np
import time
import logging
from typing import Dict, List, Optional

# Imports principales con manejo de errores mejorado
try:
    # Intentar importar desde la estructura esperada del proyecto
    from trajectory_hub.presets.artistic_presets import (
        ARTISTIC_PRESETS, 
        TRAJECTORY_FUNCTIONS,
        TEMPORAL_COMPOSITIONS,
        STYLE_CONFIGS
    )
except ImportError as e:
    # Si falla, usar definiciones m√≠nimas de respaldo
    logging.warning(f"No se pudieron importar presets art√≠sticos: {e}")
    
    ARTISTIC_PRESETS = {
        "Demo B√°sico": {
            "description": "Configuraci√≥n b√°sica para pruebas",
            "macros": [{"name": "Grupo_Demo", "sources": 10, "behavior": "flock", "formation": "circle"}],
            "trajectories": {"Grupo_Demo": "circle"},
            "distances": {"Grupo_Demo": "personal"},
            "deformations": {"Grupo_Demo": [("breathing", 4.0, 1.0)]},
            "interactions": []
        }
    }
    
    TRAJECTORY_FUNCTIONS = {
        "circle": lambda t: np.array([5*np.cos(t*0.3), 5*np.sin(t*0.3), 0]),
        "spiral": lambda t: np.array([(3+0.1*t)*np.cos(t*0.5), (3+0.1*t)*np.sin(t*0.5), 0.2*t])
    }
    
    TEMPORAL_COMPOSITIONS = {
        "Demo Simple": {
            "description": "Composici√≥n de demostraci√≥n",
            "duration": "2 minutos",
            "dynamics": "Suave",
            "timeline": []
        }
    }
    
    STYLE_CONFIGS = {
        "Demo": {
            "behaviors": ["flock", "rigid"],
            "formations": ["circle", "line"],
            "trajectories": ["circle", "spiral"],
            "source_range": {"simple": (5, 15), "medium": (10, 25), "complex": (20, 50)},
            "preferred_distances": ["personal", "social"],
            "deformations": ["breathing"]
        }
    }

# Imports del n√∫cleo del sistema
try:
    from trajectory_hub import EnhancedTrajectoryEngine, SpatOSCBridge, OSCTarget
    from trajectory_hub.core import (
        TrajectoryMovementMode, TrajectoryDisplacementMode,
        CompositeDeformer, BlendMode
    )
    from trajectory_hub.core.distance_controller import TrajectoryDistanceAdjuster, DistanceController
except ImportError as e:
    logging.error(f"Error importando componentes del n√∫cleo: {e}")
    raise

# Configuraci√≥n de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class MockOSCBridge:
    """Bridge mock para cuando OSC falla completamente"""
    def _apply_semantic_movement_to_macro(self, macro_id: str, movement_name: str, params: dict):
        """Aplicar par√°metros de movimiento sem√°ntico al macro"""
        macro = self.engine._macros[macro_id]
        source_ids = self._get_macro_source_ids(macro)
        
        # Aplicar par√°metros a cada fuente
        for sid in source_ids:
            if sid in self.engine._source_motions:
                motion = self.engine._source_motions[sid]
                
                # Aplicar vibraciones
                if 'vibration' in params:
                    if hasattr(motion, 'components') and 'individual_trajectory' in motion.components:
                        traj = motion.components['individual_trajectory']
                        if hasattr(traj, 'set_movement_mode'):
                            from trajectory_hub.core.motion_components import TrajectoryMovementMode
                            traj.set_movement_mode(
                                TrajectoryMovementMode.VIBRATION,
                                vibration_frequency=params['vibration'],
                                vibration_amplitude=0.5
                            )
                
                # Aplicar otros par√°metros seg√∫n est√©n disponibles
                for param, value in params.items():
                    if hasattr(motion, param):
                        setattr(motion, param, value)
    
    async def configure_behavior_params_safe(self):
        """Configurar par√°metros espec√≠ficos del comportamiento"""
        print("\n‚öôÔ∏è  PAR√ÅMETROS DE COMPORTAMIENTO")
        
        behavior = self.get_macro_behavior_safe(self.selected_macro)
        print(f"Comportamiento actual: {behavior}")
        
        # Par√°metros disponibles seg√∫n el comportamiento
        if behavior == "flock":
            print("\nPar√°metros de bandada:")
            separation = await self._get_float("Distancia de separaci√≥n (0.5-5.0): ", 0.5, 5.0)
            cohesion = await self._get_float("Fuerza de cohesi√≥n (0.0-1.0): ", 0.0, 1.0)
            alignment = await self._get_float("Alineaci√≥n (0.0-1.0): ", 0.0, 1.0)
            print("‚úÖ Par√°metros de bandada actualizados")
            
        elif behavior == "elastic":
            print("\nPar√°metros el√°sticos:")
            stiffness = await self._get_float("Rigidez del resorte (0.1-2.0): ", 0.1, 2.0)
            damping = await self._get_float("Amortiguaci√≥n (0.0-1.0): ", 0.0, 1.0)
            print("‚úÖ Par√°metros el√°sticos actualizados")
            
        elif behavior == "orbit":
            print("\nPar√°metros de √≥rbita:")
            radius = await self._get_float("Radio de √≥rbita (1.0-20.0): ", 1.0, 20.0)
            speed = await self._get_float("Velocidad orbital (0.1-5.0): ", 0.1, 5.0)
            print("‚úÖ Par√°metros de √≥rbita actualizados")
            
        else:
            print("\nNo hay par√°metros configurables para este comportamiento")
    
    async def toggle_movement_components_safe(self):
        """Activar/desactivar componentes espec√≠ficos de movimiento"""
        print("\nüîß COMPONENTES DE MOVIMIENTO")
        
        components = {
            "trajectory": "Trayectoria principal",
            "individual": "Trayectorias individuales",
            "vibration": "Vibraci√≥n/temblor",
            "rotation": "Rotaci√≥n/orientaci√≥n",
            "deformation": "Sistema de deformaci√≥n"
        }
        
        print("\nComponentes disponibles:")
        for i, (comp, desc) in enumerate(components.items(), 1):
            status = "‚úì Activo" if self._is_component_active(comp) else "‚úó Inactivo"
            print(f"{i}. {comp:15} - {desc:30} [{status}]")
        
        try:
            choice = await self._get_input("\nSeleccionar componente para cambiar estado (0 para salir): ")
            if choice == "0":
                return
                
            comp_list = list(components.keys())
            idx = int(choice) - 1
            
            if 0 <= idx < len(comp_list):
                component = comp_list[idx]
                new_state = self._toggle_component(component)
                status = "activado" if new_state else "desactivado"
                print(f"\n‚úÖ Componente '{component}' {status}")
            else:
                print("\n‚ö†Ô∏è  Opci√≥n no v√°lida")
                
        except Exception as e:
            print(f"\n‚ùå Error: {e}")
    
    def _is_component_active(self, component: str) -> bool:
        """Verificar si un componente est√° activo"""
        macro = self.engine._macros.get(self.selected_macro)
        if not macro:
            return False
            
        if component == "trajectory":
            return hasattr(macro, 'trajectory_component') and macro.trajectory_component is not None
        elif component == "deformation":
            return getattr(macro, 'deformation_enabled', False)
        # A√±adir m√°s verificaciones seg√∫n sea necesario
        
        return False
    
    def _toggle_component(self, component: str) -> bool:
        """Cambiar el estado de un componente"""
        macro = self.engine._macros.get(self.selected_macro)
        if not macro:
            return False
            
        if component == "deformation":
            current = getattr(macro, 'deformation_enabled', False)
            macro.deformation_enabled = not current
            return macro.deformation_enabled
            
        # A√±adir m√°s toggles seg√∫n sea necesario
        return False
    
    async def reset_movements_safe(self):
        """Resetear todos los movimientos a su estado inicial"""
        print("\nüîÑ RESETEAR MOVIMIENTOS")
        
        try:
            confirm = await self._get_bool("¬øResetear todos los movimientos del macro? (s/n): ")
            
            if confirm:
                macro = self.engine._macros[self.selected_macro]
                source_ids = self._get_macro_source_ids(macro)
                
                for sid in source_ids:
                    if sid in self.engine._source_motions:
                        motion = self.engine._source_motions[sid]
                        
                        # Resetear posici√≥n en trayectoria
                        if hasattr(motion, 'components') and 'individual_trajectory' in motion.components:
                            traj = motion.components['individual_trajectory']
                            if hasattr(traj, 'position_on_trajectory'):
                                traj.position_on_trajectory = 0.0
                        
                        # Resetear otros estados si es necesario
                        if hasattr(motion, 'state'):
                            motion.state.velocity = np.zeros(3)
                            motion.state.acceleration = np.zeros(3)
                            
                print("\n‚úÖ Movimientos reseteados")
            else:
                print("\n‚ùå Reset cancelado")
                
        except Exception as e:
            print(f"\n‚ùå Error reseteando movimientos: {e}")
            
    # =====================================
    # INTERACCI√ìN ENTRE MACROS
    # =====================================
    
    async def interaction_menu(self):
        """Men√∫ de interacci√≥n entre macros"""
        if len(self.macros) < 2:
            print("\n‚ö†Ô∏è  Se necesitan al menos 2 macros para configurar interacciones")
            return
            
        while True:
            print("\n" + "-"*40)
            print("INTERACCI√ìN ENTRE MACROS")
            print("-"*40)
            print("1. Configurar seguimiento (un macro sigue a otro)")
            print("2. Establecer atracci√≥n/repulsi√≥n mutua")
            print("3. Sincronizar movimientos")
            print("4. Crear √≥rbita (un macro orbita alrededor de otro)")
            print("5. Configurar colisiones")
            print("6. Ver interacciones activas")
            print("0. Volver")
            
            choice = await self._get_input("\nSelecci√≥n: ")
            
            try:
                if choice == "1":
                    await self.configure_following()
                elif choice == "2":
                    await self.configure_mutual_forces()
                elif choice == "3":
                    await self.sync_movements()
                elif choice == "4":
                    await self.configure_orbit()
                elif choice == "5":
                    await self.configure_collisions()
                elif choice == "6":
                    await self.show_active_interactions()
                elif choice == "0":
                    break
                else:
                    print("\n‚ö†Ô∏è  Opci√≥n no v√°lida")
                    
            except Exception as e:
                logger.error(f"Error en interacciones: {e}")
                print(f"\n‚ùå Error: {e}")
                
    async def configure_following(self):
        """Configurar un macro para que siga a otro"""
        print("\nüë• CONFIGURAR SEGUIMIENTO")
        print("Esta funci√≥n est√° en desarrollo")
        
    async def configure_mutual_forces(self):
        """Configurar atracci√≥n/repulsi√≥n entre macros"""
        print("\nüß≤ FUERZAS MUTUAS")
        print("Esta funci√≥n est√° en desarrollo")
        
    async def sync_movements(self):
        """Sincronizar movimientos entre macros"""
        print("\nüîÑ SINCRONIZAR MOVIMIENTOS")
        print("Esta funci√≥n est√° en desarrollo")
        
    async def configure_orbit(self):
        """Configurar un macro para orbitar alrededor de otro"""
        print("\nü™ê CONFIGURAR √ìRBITA")
        print("Esta funci√≥n est√° en desarrollo")
        
    async def configure_collisions(self):
        """Configurar comportamiento de colisiones"""
        print("\nüí• CONFIGURAR COLISIONES")
        print("Esta funci√≥n est√° en desarrollo")
        
    async def show_active_interactions(self):
        """Mostrar interacciones activas entre macros"""
        print("\nüìä INTERACCIONES ACTIVAS")
        print("Esta funci√≥n est√° en desarrollo")
        
    # =====================================
    # PRESETS Y COMPOSICIONES (CORREGIDO)
    # =====================================
    
    async def preset_menu(self):
        """Men√∫ de presets y composiciones"""
        while True:
            print("\n" + "-"*40)
            print("PRESETS Y COMPOSICIONES")
            print("-"*40)
            print("1. Cargar preset art√≠stico")
            print("2. Guardar configuraci√≥n actual como preset")
            print("3. Composiciones predefinidas")
            print("4. Generador aleatorio de composiciones")
            print("5. Exportar/Importar configuraci√≥n")
            print("0. Volver")
            
            choice = await self._get_input("\nSelecci√≥n: ")
            
            try:
                if choice == "1":
                    await self.load_artistic_preset()
                elif choice == "2":
                    await self.save_current_preset()
                elif choice == "3":
                    await self.load_predefined_composition()
                elif choice == "4":
                    await self.generate_random_composition()
                elif choice == "5":
                    await self.export_import_config()
                elif choice == "0":
                    break
                else:
                    print("\n‚ö†Ô∏è  Opci√≥n no v√°lida")
                    
            except Exception as e:
                logger.error(f"Error en presets: {e}")
                print(f"\n‚ùå Error: {e}")
                
    async def load_artistic_preset(self):
        """Cargar preset art√≠stico predefinido (SOLUCI√ìN DEFINITIVA)"""
        print("\nüé® PRESETS ART√çSTICOS")
        
        try:
            # Usar presets importados
            presets = ARTISTIC_PRESETS
            
            # Mostrar presets disponibles
            preset_list = list(presets.keys())
            for i, (name, data) in enumerate(presets.items(), 1):
                print(f"{i}. {name}")
                print(f"   {data['description']}")
                
            if not preset_list:
                print("\n‚ö†Ô∏è  No hay presets disponibles")
                return
                
            idx = await self._get_int("\nSeleccionar preset: ", 1, len(preset_list))
            selected_name = preset_list[idx - 1]
            preset = presets[selected_name]
            
            print(f"\n‚è≥ Cargando preset '{selected_name}'...")
            
            # Limpiar configuraci√≥n actual
            confirm = await self._get_bool("¬øEliminar macros actuales? (s/n): ")
            if confirm:
                # Eliminar todos los macros existentes de forma segura
                for macro_id in list(self.engine._macros.keys()):
                    try:
                        # Limpiar fuentes del macro
                        # Usar un enfoque gen√©rico para diferentes estructuras
                        for i in range(self.engine.max_sources):
                            if i in self.engine._source_motions:
                                if hasattr(self.engine._source_info.get(i), 'macro_id'):
                                    if self.engine._source_info[i].macro_id == macro_id:
                                        del self.engine._source_motions[i]
                                        del self.engine._source_info[i]
                    except Exception as e:
                        logger.warning(f"Error limpiando macro {macro_id}: {e}")
                        
                    # Eliminar el macro
                    if macro_id in self.engine._macros:
                        del self.engine._macros[macro_id]
                        
                self.macros.clear()
                self.selected_macro = None
                
            # Crear macros seg√∫n el preset
            created_macros = {}
            for macro_config in preset["macros"]:
                try:
                    macro_id = self.engine.create_macro(
                        name=macro_config["name"],
                        source_count=macro_config["sources"],
                        behavior=macro_config["behavior"],
                        formation=macro_config["formation"],
                        spacing=2.0
                    )
                    self.macros[macro_config["name"]] = macro_id
                    created_macros[macro_config["name"]] = macro_id
                except Exception as e:
                    logger.error(f"Error creando macro {macro_config['name']}: {e}")
                    print(f"‚ö†Ô∏è  No se pudo crear macro {macro_config['name']}")
                    
            # Configurar trayectorias
            for macro_name, traj_type in preset["trajectories"].items():
                if macro_name not in created_macros:
                    continue
                    
                if traj_type not in TRAJECTORY_FUNCTIONS:
                    logger.warning(f"Trayectoria {traj_type} no encontrada")
                    continue
                    
                macro_id = created_macros[macro_name]
                trajectory_func = TRAJECTORY_FUNCTIONS[traj_type]
                
                try:
                    # Intentar establecer la trayectoria
                    # Primero verificar que el m√©todo existe
                    if hasattr(self.engine, 'set_macro_trajectory'):
                        self.engine.set_macro_trajectory(
                            macro_id,
                            trajectory_func,
                            enable_deformation=True
                        )
                        logger.info(f"Trayectoria {traj_type} configurada para {macro_name}")
                    else:
                        # Plan B: intentar configurar directamente en el macro
                        if macro_id in self.engine._macros:
                            macro = self.engine._macros[macro_id]
                            if hasattr(macro, 'trajectory_component') and macro.trajectory_component:
                                macro.trajectory_component.set_trajectory(trajectory_func)
                                logger.info(f"Trayectoria configurada directamente en {macro_name}")
                            else:
                                logger.warning(f"No se pudo configurar trayectoria para {macro_name}")
                except Exception as e:
                    logger.error(f"Error configurando trayectoria para {macro_name}: {e}")
                    print(f"‚ö†Ô∏è  No se pudo configurar trayectoria para {macro_name}")
                    
            # Configurar distancias (con manejo de errores mejorado)
            for macro_name, distance in preset["distances"].items():
                if macro_name not in created_macros:
                    continue
                    
                macro_id = created_macros[macro_name]
                try:
                    if hasattr(self, 'distance_adjuster') and self.distance_adjuster:
                        if hasattr(self.distance_adjuster, 'adjust_macro_distance'):
                            self.distance_adjuster.adjust_macro_distance(macro_id, distance)
                            logger.info(f"Distancia {distance} configurada para {macro_name}")
                except Exception as e:
                    logger.warning(f"No se pudo configurar distancia {distance} para {macro_name}: {e}")
                        
            # Aplicar deformaciones (con verificaci√≥n robusta)
            for macro_name, deforms in preset["deformations"].items():
                if macro_name not in created_macros:
                    continue
                    
                macro_id = created_macros[macro_name]
                try:
                    # Verificar diferentes formas de acceder al deformador
                    deformer = None
                    
                    if hasattr(self.engine, 'get_deformer'):
                        deformer = self.engine.get_deformer(macro_id)
                    elif hasattr(self.engine, '_macro_deformers') and macro_id in self.engine._macro_deformers:
                        deformer = self.engine._macro_deformers[macro_id]
                    elif macro_id in self.engine._macros:
                        macro = self.engine._macros[macro_id]
                        if hasattr(macro, 'deformer'):
                            deformer = macro.deformer
                            
                    if deformer:
                        for deform_data in deforms:
                            try:
                                if deform_data[0] == "breathing":
                                    if hasattr(self.engine, 'apply_breathing'):
                                        self.engine.apply_breathing(
                                            deform_data[1], 
                                            deform_data[2], 
                                            macro_id
                                        )
                                        logger.info(f"Respiraci√≥n aplicada a {macro_name}")
                                elif deform_data[0] == "wave" and hasattr(deformer, 'add_deformer'):
                                    # Importar si es necesario
                                    try:
                                        from trajectory_hub.core.trajectory_deformers import WaveDeformer
                                        wave = WaveDeformer()
                                        if len(deform_data) > 1:
                                            wave.num_waves = deform_data[1]
                                        if len(deform_data) > 2:
                                            wave.speed = deform_data[2]
                                        deformer.add_deformer(wave)
                                        logger.info(f"Deformaci√≥n wave aplicada a {macro_name}")
                                    except:
                                        pass
                            except Exception as e:
                                logger.debug(f"Error aplicando deformaci√≥n {deform_data[0]}: {e}")
                except Exception as e:
                    logger.warning(f"Error aplicando deformaciones a {macro_name}: {e}")
                        
            # Configurar interacciones (placeholder por ahora)
            for interaction in preset.get("interactions", []):
                try:
                    logger.info(f"Interacci√≥n pendiente: {interaction}")
                except Exception as e:
                    logger.warning(f"Error procesando interacci√≥n: {e}")
                    
            # Seleccionar el primer macro como activo
            if created_macros:
                first_macro_name = list(created_macros.keys())[0]
                self.selected_macro = created_macros[first_macro_name]
                
            # Calcular estad√≠sticas finales
            total_sources = 0
            macros_exitosos = 0
            
            for macro_name, macro_id in created_macros.items():
                try:
                    # Contar fuentes creadas para este macro
                    count = 0
                    for mc in preset["macros"]:
                        if mc["name"] == macro_name:
                            count = mc["sources"]
                            break
                    total_sources += count
                    macros_exitosos += 1
                except:
                    pass
                
            print(f"\n‚úÖ Preset '{selected_name}' cargado")
            print(f"   ‚Ä¢ {macros_exitosos} macros creados exitosamente")
            print(f"   ‚Ä¢ {total_sources} fuentes totales configuradas")
            
            # Avisos sobre funcionalidades pendientes
            warnings = []
            if not hasattr(self.engine, 'set_macro_trajectory'):
                warnings.append("Trayectorias de macro no disponibles")
            if not hasattr(self, 'distance_adjuster') or not self.distance_adjuster:
                warnings.append("Control de distancias no disponible")
            if not hasattr(self.engine, 'get_deformer'):
                warnings.append("Sistema de deformaci√≥n limitado")
                
            if warnings:
                print("\n‚ö†Ô∏è  Funcionalidades limitadas:")
                for w in warnings:
                    print(f"   ‚Ä¢ {w}")
                    
        except Exception as e:
            logger.error(f"Error cargando preset: {e}")
            print(f"\n‚ùå Error cargando preset: {e}")
            
            # Mostrar m√°s detalles solo si es necesario
            if str(e).find("attribute") >= 0:
                print("\nüí° Sugerencia: El engine puede tener una versi√≥n diferente.")
                print("   Algunas caracter√≠sticas podr√≠an no estar disponibles.")
            
    async def save_current_preset(self):
        """Guardar la configuraci√≥n actual como preset"""
        print("\nüíæ GUARDAR PRESET")
        
        if not self.macros:
            print("\n‚ö†Ô∏è  No hay configuraci√≥n para guardar")
            return
            
        try:
            name = await self._get_input("Nombre del preset: ")
            description = await self._get_input("Descripci√≥n: ")
            
            # Recopilar informaci√≥n actual
            preset = {
                "name": name,
                "description": description,
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                "macros": [],
                "configurations": {}
            }
            
            for macro_name, macro_id in self.macros.items():
                macro = self.engine._macros[macro_id]
                
                # Informaci√≥n b√°sica del macro
                macro_info = {
                    "name": macro_name,
                    "id": macro_id,
                    "sources": len(macro.source_ids),
                    "behavior": macro.behavior_name,
                    "formation": macro.formation_type,
                    "spacing": macro.formation_spacing
                }
                preset["macros"].append(macro_info)
                
            # Guardar en archivo (simplificado)
            filename = f"preset_{name.replace(' ', '_')}.txt"
            print(f"\n‚úÖ Preset '{name}' guardado como {filename}")
            print(f"   {len(preset['macros'])} macros")
            print(f"   Creado: {preset['timestamp']}")
            
        except Exception as e:
            logger.error(f"Error guardando preset: {e}")
            print(f"\n‚ùå Error guardando preset: {e}")
            
    async def load_predefined_composition(self):
        """Cargar composiciones art√≠sticas completas (CORREGIDO)"""
        print("\nüé≠ COMPOSICIONES PREDEFINIDAS")
        
        try:
            # Usar composiciones importadas (CORREGIDO)
            compositions = TEMPORAL_COMPOSITIONS
            
            if not compositions:
                print("\n‚ö†Ô∏è  No hay composiciones disponibles")
                return
                
            comp_list = list(compositions.keys())
            for i, (name, data) in enumerate(compositions.items(), 1):
                print(f"\n{i}. {name}")
                print(f"   {data['description']}")
                print(f"   Duraci√≥n: {data['duration']}")
                print(f"   Din√°micas: {data['dynamics']}")
                
            choice = await self._get_int("\nSeleccionar composici√≥n: ", 1, len(comp_list))
            selected = comp_list[choice - 1]
            
            print(f"\n‚è≥ Preparando '{selected}'...")
            
            # Aqu√≠ se podr√≠a implementar la l√≥gica de timeline
            composition = compositions[selected]
            if "timeline" in composition:
                print("\nüìã Timeline de la composici√≥n:")
                for event in composition["timeline"]:
                    print(f"   {event['time']}s: {event['action']}")
                    
            print(f"\n‚úÖ Composici√≥n '{selected}' lista para reproducir")
            print("\nüí° Tip: Usa el men√∫ principal para ajustar par√°metros en tiempo real")
            
        except Exception as e:
            logger.error(f"Error cargando composici√≥n: {e}")
            print(f"\n‚ùå Error cargando composici√≥n: {e}")
            
    async def generate_random_composition(self):
        """Generar una composici√≥n aleatoria con par√°metros (CORREGIDO)"""
        print("\nüé≤ GENERADOR ALEATORIO DE COMPOSICIONES")
        
        try:
            print("\nPar√°metros de generaci√≥n:")
            
            # N√∫mero de macros
            num_macros = await self._get_int("N√∫mero de macros (1-5): ", 1, 5)
            
            # Complejidad
            print("\nComplejidad:")
            print("1. Simple (pocos elementos, movimientos b√°sicos)")
            print("2. Media (balance de elementos)")
            print("3. Compleja (muchos elementos, interacciones)")
            
            complexity = await self._get_int("Seleccionar: ", 1, 3)
            complexity_key = ["simple", "medium", "complex"][complexity - 1]
            
            # Estilo
            print("\nEstilo predominante:")
            styles = list(STYLE_CONFIGS.keys())
            if not styles:
                print("\n‚ö†Ô∏è  No hay estilos disponibles")
                return
                
            for i, style in enumerate(styles, 1):
                print(f"{i}. {style}")
                
            style_idx = await self._get_int("Seleccionar: ", 1, len(styles))
            style = styles[style_idx - 1]
            
            print(f"\nüé≤ Generando composici√≥n {style.lower()}...")
            
            # Obtener configuraci√≥n del estilo
            style_config = STYLE_CONFIGS[style]
            
            import random
            
            # Limpiar macros existentes
            confirm = await self._get_bool("¬øEliminar macros actuales? (s/n): ")
            if confirm:
                for macro_id in list(self.engine._macros.keys()):
                    macro = self.engine._macros[macro_id]
                    for sid in list(macro.source_ids):
                        if sid in self.engine._source_motions:
                            del self.engine._source_motions[sid]
                        if sid in self.engine._source_info:
                            del self.engine._source_info[sid]
                    del self.engine._macros[macro_id]
                self.macros.clear()
                self.selected_macro = None
            
            # Crear macros aleatorios
            for i in range(num_macros):
                # Crear macro aleatorio basado en el estilo
                name = f"Grupo_{chr(65+i)}"  # Grupo_A, Grupo_B, etc.
                behavior = random.choice(style_config["behaviors"])
                formation = random.choice(style_config["formations"])
                source_range = style_config["source_range"][complexity_key]
                sources = random.randint(*source_range)
                
                macro_id = self.engine.create_macro(
                    name=name,
                    source_count=sources,
                    behavior=behavior,
                    formation=formation,
                    spacing=random.uniform(1.5, 3.5)
                )
                
                self.macros[name] = macro_id
                
                # A√±adir elementos seg√∫n complejidad
                if complexity >= 2:
                    # Trayectoria
                    traj_type = random.choice(style_config["trajectories"])
                    
                    if traj_type in TRAJECTORY_FUNCTIONS:
                        self.engine.set_macro_trajectory(
                            macro_id,
                            TRAJECTORY_FUNCTIONS[traj_type],
                            enable_deformation=(complexity == 3)
                        )
                        
                    # Distancia
                    distance = random.choice(style_config["preferred_distances"])
                    try:
                        self.distance_adjuster.adjust_macro_distance(macro_id, distance)
                    except Exception as e:
                        logger.warning(f"No se pudo ajustar distancia: {e}")
                        
                if complexity == 3:
                    # A√±adir deformaci√≥n
                    deform_type = random.choice(style_config["deformations"])
                    
                    try:
                        if deform_type == "breathing":
                            period = random.uniform(3, 8)
                            amplitude = random.uniform(0.5, 2)
                            self.engine.apply_breathing(period, amplitude, macro_id)
                        elif deform_type == "chaotic":
                            deformer = self.engine.get_deformer(macro_id)
                            chaotic = deformer.get_deformer('chaotic')
                            chaotic.system_type = random.choice(["lorenz", "rossler", "chen"])
                            chaotic.scale = np.array([random.uniform(0.05, 0.2)] * 3)
                            deformer.enable_deformer('chaotic', random.uniform(0.3, 0.7))
                    except Exception as e:
                        logger.warning(f"No se pudo aplicar deformaci√≥n: {e}")
                        
            print(f"\n‚úÖ Composici√≥n {style.lower()} generada:")
            print(f"   ‚Ä¢ {num_macros} macros")
            print(f"   ‚Ä¢ Complejidad: {complexity_key.capitalize()}")
            
            total_sources = 0
            try:
                total_sources = sum(len(self.engine._macros[mid].source_ids) for mid in self.engine._macros)
            except Exception:
                pass
                
            print(f"   ‚Ä¢ Total de fuentes: {total_sources}")
            
            if self.macros:
                self.selected_macro = list(self.macros.values())[0]
                
        except Exception as e:
            logger.error(f"Error generando composici√≥n: {e}")
            print(f"\n‚ùå Error generando composici√≥n: {e}")
            
    async def export_import_config(self):
        """Exportar o importar configuraci√≥n"""
        print("\nüì¶ EXPORTAR/IMPORTAR CONFIGURACI√ìN")
        
        print("\n1. Exportar configuraci√≥n actual")
        print("2. Importar configuraci√≥n")
        print("0. Volver")
        
        choice = await self._get_input("\nSelecci√≥n: ")
        
        try:
            if choice == "1":
                print("\nüì§ EXPORTAR CONFIGURACI√ìN")
                
                if not self.macros:
                    print("\n‚ö†Ô∏è  No hay configuraci√≥n para exportar")
                    return
                    
                # Generar resumen de exportaci√≥n
                config_summary = {
                    "version": "2.0.0",
                    "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                    "engine_config": {
                        "fps": self.engine.fps,
                        "max_sources": self.engine.max_sources
                    },
                    "macros": len(self.macros),
                    "total_sources": sum(len(self.engine._macros[mid].source_ids) for mid in self.engine._macros),
                    "active_deformers": 0  # Simplificado
                }
                
                filename = f"trajectory_hub_config_{time.strftime('%Y%m%d_%H%M%S')}.json"
                
                print(f"\n‚úÖ Configuraci√≥n exportada:")
                print(f"   Archivo: {filename}")
                print(f"   Macros: {config_summary['macros']}")
                print(f"   Fuentes totales: {config_summary['total_sources']}")
                
            elif choice == "2":
                print("\nüì• IMPORTAR CONFIGURACI√ìN")
                print("\n‚ö†Ô∏è  Esta funci√≥n est√° en desarrollo")
                print("   Por ahora, usa los presets art√≠sticos del men√∫ anterior")
            else:
                print("\n‚ö†Ô∏è  Opci√≥n no v√°lida")
                
        except Exception as e:
            logger.error(f"Error en export/import: {e}")
            print(f"\n‚ùå Error: {e}")
            
    # =====================================
    # INFORMACI√ìN DEL SISTEMA
    # =====================================
    
    async def system_info(self):
        """Mostrar informaci√≥n del sistema"""
        print("\n" + "="*60)
        print("INFORMACI√ìN DEL SISTEMA")
        print("="*60)
        
        try:
            # Info del engine
            print(f"\nüéØ Engine:")
            print(f"  ‚Ä¢ FPS: {self.engine.fps}")
            print(f"  ‚Ä¢ Fuentes m√°ximas: {self.engine.max_sources}")
            print(f"  ‚Ä¢ Fuentes activas: {len(self.engine._source_motions)}")
            
            # Info de macros
            print(f"\nüì¶ Macros:")
            if self.macros:
                for name, macro_id in self.macros.items():
                    macro = self.engine._macros.get(macro_id)
                    if macro:
                        selected = "‚Üí" if macro_id == self.selected_macro else " "
                        print(f"  {selected} {name}: {len(macro.source_ids)} fuentes, '{macro.behavior_name}'")
            else:
                print("  ‚Ä¢ No hay macros creados")
                
            # Info OSC
            print(f"\nüì° OSC:")
            try:
                stats = self.bridge.get_stats()
                print(f"  ‚Ä¢ Targets activos: {stats['active_targets']}/{stats.get('total_targets', stats['active_targets'])}")
                print(f"  ‚Ä¢ Mensajes enviados: {stats['messages_sent']:,}")
                print(f"  ‚Ä¢ Tasa de mensajes: {stats['message_rate']:.1f} msg/s")
                
                # Nuevas estad√≠sticas si est√°n disponibles
                if 'success_rate' in stats:
                    print(f"  ‚Ä¢ Tasa de √©xito: {stats['success_rate']:.1f}%")
                if 'uptime_formatted' in stats:
                    print(f"  ‚Ä¢ Tiempo activo: {stats['uptime_formatted']}")
                
                # Mostrar errores si hay
                if stats.get('messages_failed', 0) > 0:
                    print(f"  ‚Ä¢ ‚ö†Ô∏è  Mensajes fallidos: {stats['messages_failed']:,}")
                    
                # Mostrar targets con fallos si hay
                if stats.get('failed_targets'):
                    print(f"  ‚Ä¢ ‚ùå Targets con fallos: {', '.join(stats['failed_targets'])}")
                    
            except Exception as e:
                print(f"  ‚Ä¢ Estado: Error obteniendo estad√≠sticas ({e})")
                
            # Info de presets
            print(f"\nüé® Presets disponibles:")
            print(f"  ‚Ä¢ Art√≠sticos: {len(ARTISTIC_PRESETS)}")
            print(f"  ‚Ä¢ Composiciones: {len(TEMPORAL_COMPOSITIONS)}")
            print(f"  ‚Ä¢ Estilos: {len(STYLE_CONFIGS)}")
            print(f"  ‚Ä¢ Funciones de trayectoria: {len(TRAJECTORY_FUNCTIONS)}")
            
        except Exception as e:
            logger.error(f"Error obteniendo info del sistema: {e}")
            print(f"\n‚ùå Error obteniendo informaci√≥n: {e}")
            
        await self._get_input("\nPresiona Enter para continuar...")
        
    # =====================================
    # M√âTODOS AUXILIARES
    # =====================================
    
    def _get_macro_name(self, macro_id: str) -> str:
        """Obtener nombre de un macro por ID"""
        for name, mid in self.macros.items():
            if mid == macro_id:
                return name
        return macro_id
        
    async def _get_input(self, prompt: str) -> str:
        """Obtener input del usuario"""
        return await asyncio.get_event_loop().run_in_executor(None, input, prompt)
        
    async def _get_int(self, prompt: str, min_val: int, max_val: int) -> int:
        """Obtener entero validado"""
        while True:
            try:
                val = int(await self._get_input(prompt))
                if min_val <= val <= max_val:
                    return val
                print(f"Por favor, ingrese un n√∫mero entre {min_val} y {max_val}")
            except ValueError:
                print("Por favor, ingrese un n√∫mero v√°lido")
                
    async def _get_float(self, prompt: str, min_val: float, max_val: float) -> float:
        """Obtener float validado"""
        while True:
            try:
                val = float(await self._get_input(prompt))
                if min_val <= val <= max_val:
                    return val
                print(f"Por favor, ingrese un n√∫mero entre {min_val} y {max_val}")
            except ValueError:
                print("Por favor, ingrese un n√∫mero v√°lido")
                
    async def _get_bool(self, prompt: str) -> bool:
        """Obtener booleano"""
        response = await self._get_input(prompt)
        return response.lower() in ['s', 'si', 's√≠', 'y', 'yes', '1', 'true']

       
    """Bridge mock para cuando OSC falla completamente"""
    def _apply_semantic_movement_to_macro(self, macro_id: str, movement_name: str, params: dict):
        """Aplicar par√°metros de movimiento sem√°ntico al macro"""
        macro = self.engine._macros[macro_id]
        source_ids = self._get_macro_source_ids(macro)
        
        # Aplicar par√°metros a cada fuente
        for sid in source_ids:
            if sid in self.engine._source_motions:
                motion = self.engine._source_motions[sid]
                
                # Aplicar vibraciones
                if 'vibration' in params:
                    if hasattr(motion, 'components') and 'individual_trajectory' in motion.components:
                        traj = motion.components['individual_trajectory']
                        if hasattr(traj, 'set_movement_mode'):
                            from trajectory_hub.core.motion_components import TrajectoryMovementMode
                            traj.set_movement_mode(
                                TrajectoryMovementMode.VIBRATION,
                                vibration_frequency=params['vibration'],
                                vibration_amplitude=0.5
                            )
                
                # Aplicar otros par√°metros seg√∫n est√©n disponibles
                for param, value in params.items():
                    if hasattr(motion, param):
                        setattr(motion, param, value)
    
    async def configure_behavior_params_safe(self):
        """Configurar par√°metros espec√≠ficos del comportamiento"""
        print("\n‚öôÔ∏è  PAR√ÅMETROS DE COMPORTAMIENTO")
        
        behavior = self.get_macro_behavior_safe(self.selected_macro)
        print(f"Comportamiento actual: {behavior}")
        
        # Par√°metros disponibles seg√∫n el comportamiento
        if behavior == "flock":
            print("\nPar√°metros de bandada:")
            separation = await self._get_float("Distancia de separaci√≥n (0.5-5.0): ", 0.5, 5.0)
            cohesion = await self._get_float("Fuerza de cohesi√≥n (0.0-1.0): ", 0.0, 1.0)
            alignment = await self._get_float("Alineaci√≥n (0.0-1.0): ", 0.0, 1.0)
            print("‚úÖ Par√°metros de bandada actualizados")
            
        elif behavior == "elastic":
            print("\nPar√°metros el√°sticos:")
            stiffness = await self._get_float("Rigidez del resorte (0.1-2.0): ", 0.1, 2.0)
            damping = await self._get_float("Amortiguaci√≥n (0.0-1.0): ", 0.0, 1.0)
            print("‚úÖ Par√°metros el√°sticos actualizados")
            
        elif behavior == "orbit":
            print("\nPar√°metros de √≥rbita:")
            radius = await self._get_float("Radio de √≥rbita (1.0-20.0): ", 1.0, 20.0)
            speed = await self._get_float("Velocidad orbital (0.1-5.0): ", 0.1, 5.0)
            print("‚úÖ Par√°metros de √≥rbita actualizados")
            
        else:
            print("\nNo hay par√°metros configurables para este comportamiento")
    
    async def toggle_movement_components_safe(self):
        """Activar/desactivar componentes espec√≠ficos de movimiento"""
        print("\nüîß COMPONENTES DE MOVIMIENTO")
        
        components = {
            "trajectory": "Trayectoria principal",
            "individual": "Trayectorias individuales",
            "vibration": "Vibraci√≥n/temblor",
            "rotation": "Rotaci√≥n/orientaci√≥n",
            "deformation": "Sistema de deformaci√≥n"
        }
        
        print("\nComponentes disponibles:")
        for i, (comp, desc) in enumerate(components.items(), 1):
            status = "‚úì Activo" if self._is_component_active(comp) else "‚úó Inactivo"
            print(f"{i}. {comp:15} - {desc:30} [{status}]")
        
        try:
            choice = await self._get_input("\nSeleccionar componente para cambiar estado (0 para salir): ")
            if choice == "0":
                return
                
            comp_list = list(components.keys())
            idx = int(choice) - 1
            
            if 0 <= idx < len(comp_list):
                component = comp_list[idx]
                new_state = self._toggle_component(component)
                status = "activado" if new_state else "desactivado"
                print(f"\n‚úÖ Componente '{component}' {status}")
            else:
                print("\n‚ö†Ô∏è  Opci√≥n no v√°lida")
                
        except Exception as e:
            print(f"\n‚ùå Error: {e}")
    
    def _is_component_active(self, component: str) -> bool:
        """Verificar si un componente est√° activo"""
        macro = self.engine._macros.get(self.selected_macro)
        if not macro:
            return False
            
        if component == "trajectory":
            return hasattr(macro, 'trajectory_component') and macro.trajectory_component is not None
        elif component == "deformation":
            return getattr(macro, 'deformation_enabled', False)
        # A√±adir m√°s verificaciones seg√∫n sea necesario
        
        return False
    
    def _toggle_component(self, component: str) -> bool:
        """Cambiar el estado de un componente"""
        macro = self.engine._macros.get(self.selected_macro)
        if not macro:
            return False
            
        if component == "deformation":
            current = getattr(macro, 'deformation_enabled', False)
            macro.deformation_enabled = not current
            return macro.deformation_enabled
            
        # A√±adir m√°s toggles seg√∫n sea necesario
        return False
    
    async def reset_movements_safe(self):
        """Resetear todos los movimientos a su estado inicial"""
        print("\nüîÑ RESETEAR MOVIMIENTOS")
        
        try:
            confirm = await self._get_bool("¬øResetear todos los movimientos del macro? (s/n): ")
            
            if confirm:
                macro = self.engine._macros[self.selected_macro]
                source_ids = self._get_macro_source_ids(macro)
                
                for sid in source_ids:
                    if sid in self.engine._source_motions:
                        motion = self.engine._source_motions[sid]
                        
                        # Resetear posici√≥n en trayectoria
                        if hasattr(motion, 'components') and 'individual_trajectory' in motion.components:
                            traj = motion.components['individual_trajectory']
                            if hasattr(traj, 'position_on_trajectory'):
                                traj.position_on_trajectory = 0.0
                        
                        # Resetear otros estados si es necesario
                        if hasattr(motion, 'state'):
                            motion.state.velocity = np.zeros(3)
                            motion.state.acceleration = np.zeros(3)
                            
                print("\n‚úÖ Movimientos reseteados")
            else:
                print("\n‚ùå Reset cancelado")
                
        except Exception as e:
            print(f"\n‚ùå Error reseteando movimientos: {e}")
            
    # =====================================
    # INTERACCI√ìN ENTRE MACROS
    # =====================================
    
    async def interaction_menu(self):
        """Men√∫ de interacci√≥n entre macros"""
        if len(self.macros) < 2:
            print("\n‚ö†Ô∏è  Se necesitan al menos 2 macros para configurar interacciones")
            return
            
        while True:
            print("\n" + "-"*40)
            print("INTERACCI√ìN ENTRE MACROS")
            print("-"*40)
            print("1. Configurar seguimiento (un macro sigue a otro)")
            print("2. Establecer atracci√≥n/repulsi√≥n mutua")
            print("3. Sincronizar movimientos")
            print("4. Crear √≥rbita (un macro orbita alrededor de otro)")
            print("5. Configurar colisiones")
            print("6. Ver interacciones activas")
            print("0. Volver")
            
            choice = await self._get_input("\nSelecci√≥n: ")
            
            try:
                if choice == "1":
                    await self.configure_following()
                elif choice == "2":
                    await self.configure_mutual_forces()
                elif choice == "3":
                    await self.sync_movements()
                elif choice == "4":
                    await self.configure_orbit()
                elif choice == "5":
                    await self.configure_collisions()
                elif choice == "6":
                    await self.show_active_interactions()
                elif choice == "0":
                    break
                else:
                    print("\n‚ö†Ô∏è  Opci√≥n no v√°lida")
                    
            except Exception as e:
                logger.error(f"Error en interacciones: {e}")
                print(f"\n‚ùå Error: {e}")
                
    async def configure_following(self):
        """Configurar un macro para que siga a otro"""
        print("\nüë• CONFIGURAR SEGUIMIENTO")
        print("Esta funci√≥n est√° en desarrollo")
        
    async def configure_mutual_forces(self):
        """Configurar atracci√≥n/repulsi√≥n entre macros"""
        print("\nüß≤ FUERZAS MUTUAS")
        print("Esta funci√≥n est√° en desarrollo")
        
    async def sync_movements(self):
        """Sincronizar movimientos entre macros"""
        print("\nüîÑ SINCRONIZAR MOVIMIENTOS")
        print("Esta funci√≥n est√° en desarrollo")
        
    async def configure_orbit(self):
        """Configurar un macro para orbitar alrededor de otro"""
        print("\nü™ê CONFIGURAR √ìRBITA")
        print("Esta funci√≥n est√° en desarrollo")
        
    async def configure_collisions(self):
        """Configurar comportamiento de colisiones"""
        print("\nüí• CONFIGURAR COLISIONES")
        print("Esta funci√≥n est√° en desarrollo")
        
    async def show_active_interactions(self):
        """Mostrar interacciones activas entre macros"""
        print("\nüìä INTERACCIONES ACTIVAS")
        print("Esta funci√≥n est√° en desarrollo")
        
    # =====================================
    # PRESETS Y COMPOSICIONES (CORREGIDO)
    # =====================================
    
    async def preset_menu(self):
        """Men√∫ de presets y composiciones"""
        while True:
            print("\n" + "-"*40)
            print("PRESETS Y COMPOSICIONES")
            print("-"*40)
            print("1. Cargar preset art√≠stico")
            print("2. Guardar configuraci√≥n actual como preset")
            print("3. Composiciones predefinidas")
            print("4. Generador aleatorio de composiciones")
            print("5. Exportar/Importar configuraci√≥n")
            print("0. Volver")
            
            choice = await self._get_input("\nSelecci√≥n: ")
            
            try:
                if choice == "1":
                    await self.load_artistic_preset()
                elif choice == "2":
                    await self.save_current_preset()
                elif choice == "3":
                    await self.load_predefined_composition()
                elif choice == "4":
                    await self.generate_random_composition()
                elif choice == "5":
                    await self.export_import_config()
                elif choice == "0":
                    break
                else:
                    print("\n‚ö†Ô∏è  Opci√≥n no v√°lida")
                    
            except Exception as e:
                logger.error(f"Error en presets: {e}")
                print(f"\n‚ùå Error: {e}")
                
    async def load_artistic_preset(self):
        """Cargar preset art√≠stico predefinido (SOLUCI√ìN DEFINITIVA)"""
        print("\nüé® PRESETS ART√çSTICOS")
        
        try:
            # Usar presets importados
            presets = ARTISTIC_PRESETS
            
            # Mostrar presets disponibles
            preset_list = list(presets.keys())
            for i, (name, data) in enumerate(presets.items(), 1):
                print(f"{i}. {name}")
                print(f"   {data['description']}")
                
            if not preset_list:
                print("\n‚ö†Ô∏è  No hay presets disponibles")
                return
                
            idx = await self._get_int("\nSeleccionar preset: ", 1, len(preset_list))
            selected_name = preset_list[idx - 1]
            preset = presets[selected_name]
            
            print(f"\n‚è≥ Cargando preset '{selected_name}'...")
            
            # Limpiar configuraci√≥n actual
            confirm = await self._get_bool("¬øEliminar macros actuales? (s/n): ")
            if confirm:
                # Eliminar todos los macros existentes de forma segura
                for macro_id in list(self.engine._macros.keys()):
                    try:
                        # Limpiar fuentes del macro
                        # Usar un enfoque gen√©rico para diferentes estructuras
                        for i in range(self.engine.max_sources):
                            if i in self.engine._source_motions:
                                if hasattr(self.engine._source_info.get(i), 'macro_id'):
                                    if self.engine._source_info[i].macro_id == macro_id:
                                        del self.engine._source_motions[i]
                                        del self.engine._source_info[i]
                    except Exception as e:
                        logger.warning(f"Error limpiando macro {macro_id}: {e}")
                        
                    # Eliminar el macro
                    if macro_id in self.engine._macros:
                        del self.engine._macros[macro_id]
                        
                self.macros.clear()
                self.selected_macro = None
                
            # Crear macros seg√∫n el preset
            created_macros = {}
            for macro_config in preset["macros"]:
                try:
                    macro_id = self.engine.create_macro(
                        name=macro_config["name"],
                        source_count=macro_config["sources"],
                        behavior=macro_config["behavior"],
                        formation=macro_config["formation"],
                        spacing=2.0
                    )
                    self.macros[macro_config["name"]] = macro_id
                    created_macros[macro_config["name"]] = macro_id
                except Exception as e:
                    logger.error(f"Error creando macro {macro_config['name']}: {e}")
                    print(f"‚ö†Ô∏è  No se pudo crear macro {macro_config['name']}")
                    
            # Configurar trayectorias
            for macro_name, traj_type in preset["trajectories"].items():
                if macro_name not in created_macros:
                    continue
                    
                if traj_type not in TRAJECTORY_FUNCTIONS:
                    logger.warning(f"Trayectoria {traj_type} no encontrada")
                    continue
                    
                macro_id = created_macros[macro_name]
                trajectory_func = TRAJECTORY_FUNCTIONS[traj_type]
                
                try:
                    # Intentar establecer la trayectoria
                    # Primero verificar que el m√©todo existe
                    if hasattr(self.engine, 'set_macro_trajectory'):
                        self.engine.set_macro_trajectory(
                            macro_id,
                            trajectory_func,
                            enable_deformation=True
                        )
                        logger.info(f"Trayectoria {traj_type} configurada para {macro_name}")
                    else:
                        # Plan B: intentar configurar directamente en el macro
                        if macro_id in self.engine._macros:
                            macro = self.engine._macros[macro_id]
                            if hasattr(macro, 'trajectory_component') and macro.trajectory_component:
                                macro.trajectory_component.set_trajectory(trajectory_func)
                                logger.info(f"Trayectoria configurada directamente en {macro_name}")
                            else:
                                logger.warning(f"No se pudo configurar trayectoria para {macro_name}")
                except Exception as e:
                    logger.error(f"Error configurando trayectoria para {macro_name}: {e}")
                    print(f"‚ö†Ô∏è  No se pudo configurar trayectoria para {macro_name}")
                    
            # Configurar distancias (con manejo de errores mejorado)
            for macro_name, distance in preset["distances"].items():
                if macro_name not in created_macros:
                    continue
                    
                macro_id = created_macros[macro_name]
                try:
                    if hasattr(self, 'distance_adjuster') and self.distance_adjuster:
                        if hasattr(self.distance_adjuster, 'adjust_macro_distance'):
                            self.distance_adjuster.adjust_macro_distance(macro_id, distance)
                            logger.info(f"Distancia {distance} configurada para {macro_name}")
                except Exception as e:
                    logger.warning(f"No se pudo configurar distancia {distance} para {macro_name}: {e}")
                        
            # Aplicar deformaciones (con verificaci√≥n robusta)
            for macro_name, deforms in preset["deformations"].items():
                if macro_name not in created_macros:
                    continue
                    
                macro_id = created_macros[macro_name]
                try:
                    # Verificar diferentes formas de acceder al deformador
                    deformer = None
                    
                    if hasattr(self.engine, 'get_deformer'):
                        deformer = self.engine.get_deformer(macro_id)
                    elif hasattr(self.engine, '_macro_deformers') and macro_id in self.engine._macro_deformers:
                        deformer = self.engine._macro_deformers[macro_id]
                    elif macro_id in self.engine._macros:
                        macro = self.engine._macros[macro_id]
                        if hasattr(macro, 'deformer'):
                            deformer = macro.deformer
                            
                    if deformer:
                        for deform_data in deforms:
                            try:
                                if deform_data[0] == "breathing":
                                    if hasattr(self.engine, 'apply_breathing'):
                                        self.engine.apply_breathing(
                                            deform_data[1], 
                                            deform_data[2], 
                                            macro_id
                                        )
                                        logger.info(f"Respiraci√≥n aplicada a {macro_name}")
                                elif deform_data[0] == "wave" and hasattr(deformer, 'add_deformer'):
                                    # Importar si es necesario
                                    try:
                                        from trajectory_hub.core.trajectory_deformers import WaveDeformer
                                        wave = WaveDeformer()
                                        if len(deform_data) > 1:
                                            wave.num_waves = deform_data[1]
                                        if len(deform_data) > 2:
                                            wave.speed = deform_data[2]
                                        deformer.add_deformer(wave)
                                        logger.info(f"Deformaci√≥n wave aplicada a {macro_name}")
                                    except:
                                        pass
                            except Exception as e:
                                logger.debug(f"Error aplicando deformaci√≥n {deform_data[0]}: {e}")
                except Exception as e:
                    logger.warning(f"Error aplicando deformaciones a {macro_name}: {e}")
                        
            # Configurar interacciones (placeholder por ahora)
            for interaction in preset.get("interactions", []):
                try:
                    logger.info(f"Interacci√≥n pendiente: {interaction}")
                except Exception as e:
                    logger.warning(f"Error procesando interacci√≥n: {e}")
                    
            # Seleccionar el primer macro como activo
            if created_macros:
                first_macro_name = list(created_macros.keys())[0]
                self.selected_macro = created_macros[first_macro_name]
                
            # Calcular estad√≠sticas finales
            total_sources = 0
            macros_exitosos = 0
            
            for macro_name, macro_id in created_macros.items():
                try:
                    # Contar fuentes creadas para este macro
                    count = 0
                    for mc in preset["macros"]:
                        if mc["name"] == macro_name:
                            count = mc["sources"]
                            break
                    total_sources += count
                    macros_exitosos += 1
                except:
                    pass
                
            print(f"\n‚úÖ Preset '{selected_name}' cargado")
            print(f"   ‚Ä¢ {macros_exitosos} macros creados exitosamente")
            print(f"   ‚Ä¢ {total_sources} fuentes totales configuradas")
            
            # Avisos sobre funcionalidades pendientes
            warnings = []
            if not hasattr(self.engine, 'set_macro_trajectory'):
                warnings.append("Trayectorias de macro no disponibles")
            if not hasattr(self, 'distance_adjuster') or not self.distance_adjuster:
                warnings.append("Control de distancias no disponible")
            if not hasattr(self.engine, 'get_deformer'):
                warnings.append("Sistema de deformaci√≥n limitado")
                
            if warnings:
                print("\n‚ö†Ô∏è  Funcionalidades limitadas:")
                for w in warnings:
                    print(f"   ‚Ä¢ {w}")
                    
        except Exception as e:
            logger.error(f"Error cargando preset: {e}")
            print(f"\n‚ùå Error cargando preset: {e}")
            
            # Mostrar m√°s detalles solo si es necesario
            if str(e).find("attribute") >= 0:
                print("\nüí° Sugerencia: El engine puede tener una versi√≥n diferente.")
                print("   Algunas caracter√≠sticas podr√≠an no estar disponibles.")
            
    async def save_current_preset(self):
        """Guardar la configuraci√≥n actual como preset"""
        print("\nüíæ GUARDAR PRESET")
        
        if not self.macros:
            print("\n‚ö†Ô∏è  No hay configuraci√≥n para guardar")
            return
            
        try:
            name = await self._get_input("Nombre del preset: ")
            description = await self._get_input("Descripci√≥n: ")
            
            # Recopilar informaci√≥n actual
            preset = {
                "name": name,
                "description": description,
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                "macros": [],
                "configurations": {}
            }
            
            for macro_name, macro_id in self.macros.items():
                macro = self.engine._macros[macro_id]
                
                # Informaci√≥n b√°sica del macro
                macro_info = {
                    "name": macro_name,
                    "id": macro_id,
                    "sources": len(macro.source_ids),
                    "behavior": macro.behavior_name,
                    "formation": macro.formation_type,
                    "spacing": macro.formation_spacing
                }
                preset["macros"].append(macro_info)
                
            # Guardar en archivo (simplificado)
            filename = f"preset_{name.replace(' ', '_')}.txt"
            print(f"\n‚úÖ Preset '{name}' guardado como {filename}")
            print(f"   {len(preset['macros'])} macros")
            print(f"   Creado: {preset['timestamp']}")
            
        except Exception as e:
            logger.error(f"Error guardando preset: {e}")
            print(f"\n‚ùå Error guardando preset: {e}")
            
    async def load_predefined_composition(self):
        """Cargar composiciones art√≠sticas completas (CORREGIDO)"""
        print("\nüé≠ COMPOSICIONES PREDEFINIDAS")
        
        try:
            # Usar composiciones importadas (CORREGIDO)
            compositions = TEMPORAL_COMPOSITIONS
            
            if not compositions:
                print("\n‚ö†Ô∏è  No hay composiciones disponibles")
                return
                
            comp_list = list(compositions.keys())
            for i, (name, data) in enumerate(compositions.items(), 1):
                print(f"\n{i}. {name}")
                print(f"   {data['description']}")
                print(f"   Duraci√≥n: {data['duration']}")
                print(f"   Din√°micas: {data['dynamics']}")
                
            choice = await self._get_int("\nSeleccionar composici√≥n: ", 1, len(comp_list))
            selected = comp_list[choice - 1]
            
            print(f"\n‚è≥ Preparando '{selected}'...")
            
            # Aqu√≠ se podr√≠a implementar la l√≥gica de timeline
            composition = compositions[selected]
            if "timeline" in composition:
                print("\nüìã Timeline de la composici√≥n:")
                for event in composition["timeline"]:
                    print(f"   {event['time']}s: {event['action']}")
                    
            print(f"\n‚úÖ Composici√≥n '{selected}' lista para reproducir")
            print("\nüí° Tip: Usa el men√∫ principal para ajustar par√°metros en tiempo real")
            
        except Exception as e:
            logger.error(f"Error cargando composici√≥n: {e}")
            print(f"\n‚ùå Error cargando composici√≥n: {e}")
            
    async def generate_random_composition(self):
        """Generar una composici√≥n aleatoria con par√°metros (CORREGIDO)"""
        print("\nüé≤ GENERADOR ALEATORIO DE COMPOSICIONES")
        
        try:
            print("\nPar√°metros de generaci√≥n:")
            
            # N√∫mero de macros
            num_macros = await self._get_int("N√∫mero de macros (1-5): ", 1, 5)
            
            # Complejidad
            print("\nComplejidad:")
            print("1. Simple (pocos elementos, movimientos b√°sicos)")
            print("2. Media (balance de elementos)")
            print("3. Compleja (muchos elementos, interacciones)")
            
            complexity = await self._get_int("Seleccionar: ", 1, 3)
            complexity_key = ["simple", "medium", "complex"][complexity - 1]
            
            # Estilo
            print("\nEstilo predominante:")
            styles = list(STYLE_CONFIGS.keys())
            if not styles:
                print("\n‚ö†Ô∏è  No hay estilos disponibles")
                return
                
            for i, style in enumerate(styles, 1):
                print(f"{i}. {style}")
                
            style_idx = await self._get_int("Seleccionar: ", 1, len(styles))
            style = styles[style_idx - 1]
            
            print(f"\nüé≤ Generando composici√≥n {style.lower()}...")
            
            # Obtener configuraci√≥n del estilo
            style_config = STYLE_CONFIGS[style]
            
            import random
            
            # Limpiar macros existentes
            confirm = await self._get_bool("¬øEliminar macros actuales? (s/n): ")
            if confirm:
                for macro_id in list(self.engine._macros.keys()):
                    macro = self.engine._macros[macro_id]
                    for sid in list(macro.source_ids):
                        if sid in self.engine._source_motions:
                            del self.engine._source_motions[sid]
                        if sid in self.engine._source_info:
                            del self.engine._source_info[sid]
                    del self.engine._macros[macro_id]
                self.macros.clear()
                self.selected_macro = None
            
            # Crear macros aleatorios
            for i in range(num_macros):
                # Crear macro aleatorio basado en el estilo
                name = f"Grupo_{chr(65+i)}"  # Grupo_A, Grupo_B, etc.
                behavior = random.choice(style_config["behaviors"])
                formation = random.choice(style_config["formations"])
                source_range = style_config["source_range"][complexity_key]
                sources = random.randint(*source_range)
                
                macro_id = self.engine.create_macro(
                    name=name,
                    source_count=sources,
                    behavior=behavior,
                    formation=formation,
                    spacing=random.uniform(1.5, 3.5)
                )
                
                self.macros[name] = macro_id
                
                # A√±adir elementos seg√∫n complejidad
                if complexity >= 2:
                    # Trayectoria
                    traj_type = random.choice(style_config["trajectories"])
                    
                    if traj_type in TRAJECTORY_FUNCTIONS:
                        self.engine.set_macro_trajectory(
                            macro_id,
                            TRAJECTORY_FUNCTIONS[traj_type],
                            enable_deformation=(complexity == 3)
                        )
                        
                    # Distancia
                    distance = random.choice(style_config["preferred_distances"])
                    try:
                        self.distance_adjuster.adjust_macro_distance(macro_id, distance)
                    except Exception as e:
                        logger.warning(f"No se pudo ajustar distancia: {e}")
                        
                if complexity == 3:
                    # A√±adir deformaci√≥n
                    deform_type = random.choice(style_config["deformations"])
                    
                    try:
                        if deform_type == "breathing":
                            period = random.uniform(3, 8)
                            amplitude = random.uniform(0.5, 2)
                            self.engine.apply_breathing(period, amplitude, macro_id)
                        elif deform_type == "chaotic":
                            deformer = self.engine.get_deformer(macro_id)
                            chaotic = deformer.get_deformer('chaotic')
                            chaotic.system_type = random.choice(["lorenz", "rossler", "chen"])
                            chaotic.scale = np.array([random.uniform(0.05, 0.2)] * 3)
                            deformer.enable_deformer('chaotic', random.uniform(0.3, 0.7))
                    except Exception as e:
                        logger.warning(f"No se pudo aplicar deformaci√≥n: {e}")
                        
            print(f"\n‚úÖ Composici√≥n {style.lower()} generada:")
            print(f"   ‚Ä¢ {num_macros} macros")
            print(f"   ‚Ä¢ Complejidad: {complexity_key.capitalize()}")
            
            total_sources = 0
            try:
                total_sources = sum(len(self.engine._macros[mid].source_ids) for mid in self.engine._macros)
            except Exception:
                pass
                
            print(f"   ‚Ä¢ Total de fuentes: {total_sources}")
            
            if self.macros:
                self.selected_macro = list(self.macros.values())[0]
                
        except Exception as e:
            logger.error(f"Error generando composici√≥n: {e}")
            print(f"\n‚ùå Error generando composici√≥n: {e}")
            
    async def export_import_config(self):
        """Exportar o importar configuraci√≥n"""
        print("\nüì¶ EXPORTAR/IMPORTAR CONFIGURACI√ìN")
        
        print("\n1. Exportar configuraci√≥n actual")
        print("2. Importar configuraci√≥n")
        print("0. Volver")
        
        choice = await self._get_input("\nSelecci√≥n: ")
        
        try:
            if choice == "1":
                print("\nüì§ EXPORTAR CONFIGURACI√ìN")
                
                if not self.macros:
                    print("\n‚ö†Ô∏è  No hay configuraci√≥n para exportar")
                    return
                    
                # Generar resumen de exportaci√≥n
                config_summary = {
                    "version": "2.0.0",
                    "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                    "engine_config": {
                        "fps": self.engine.fps,
                        "max_sources": self.engine.max_sources
                    },
                    "macros": len(self.macros),
                    "total_sources": sum(len(self.engine._macros[mid].source_ids) for mid in self.engine._macros),
                    "active_deformers": 0  # Simplificado
                }
                
                filename = f"trajectory_hub_config_{time.strftime('%Y%m%d_%H%M%S')}.json"
                
                print(f"\n‚úÖ Configuraci√≥n exportada:")
                print(f"   Archivo: {filename}")
                print(f"   Macros: {config_summary['macros']}")
                print(f"   Fuentes totales: {config_summary['total_sources']}")
                
            elif choice == "2":
                print("\nüì• IMPORTAR CONFIGURACI√ìN")
                print("\n‚ö†Ô∏è  Esta funci√≥n est√° en desarrollo")
                print("   Por ahora, usa los presets art√≠sticos del men√∫ anterior")
            else:
                print("\n‚ö†Ô∏è  Opci√≥n no v√°lida")
                
        except Exception as e:
            logger.error(f"Error en export/import: {e}")
            print(f"\n‚ùå Error: {e}")
            
    # =====================================
    # INFORMACI√ìN DEL SISTEMA
    # =====================================
    
    async def system_info(self):
        """Mostrar informaci√≥n del sistema"""
        print("\n" + "="*60)
        print("INFORMACI√ìN DEL SISTEMA")
        print("="*60)
        
        try:
            # Info del engine
            print(f"\nüéØ Engine:")
            print(f"  ‚Ä¢ FPS: {self.engine.fps}")
            print(f"  ‚Ä¢ Fuentes m√°ximas: {self.engine.max_sources}")
            print(f"  ‚Ä¢ Fuentes activas: {len(self.engine._source_motions)}")
            
            # Info de macros
            print(f"\nüì¶ Macros:")
            if self.macros:
                for name, macro_id in self.macros.items():
                    macro = self.engine._macros.get(macro_id)
                    if macro:
                        selected = "‚Üí" if macro_id == self.selected_macro else " "
                        print(f"  {selected} {name}: {len(macro.source_ids)} fuentes, '{macro.behavior_name}'")
            else:
                print("  ‚Ä¢ No hay macros creados")
                
            # Info OSC
            print(f"\nüì° OSC:")
            try:
                stats = self.bridge.get_stats()
                print(f"  ‚Ä¢ Targets activos: {stats['active_targets']}/{stats.get('total_targets', stats['active_targets'])}")
                print(f"  ‚Ä¢ Mensajes enviados: {stats['messages_sent']:,}")
                print(f"  ‚Ä¢ Tasa de mensajes: {stats['message_rate']:.1f} msg/s")
                
                # Nuevas estad√≠sticas si est√°n disponibles
                if 'success_rate' in stats:
                    print(f"  ‚Ä¢ Tasa de √©xito: {stats['success_rate']:.1f}%")
                if 'uptime_formatted' in stats:
                    print(f"  ‚Ä¢ Tiempo activo: {stats['uptime_formatted']}")
                
                # Mostrar errores si hay
                if stats.get('messages_failed', 0) > 0:
                    print(f"  ‚Ä¢ ‚ö†Ô∏è  Mensajes fallidos: {stats['messages_failed']:,}")
                    
                # Mostrar targets con fallos si hay
                if stats.get('failed_targets'):
                    print(f"  ‚Ä¢ ‚ùå Targets con fallos: {', '.join(stats['failed_targets'])}")
                    
            except Exception as e:
                print(f"  ‚Ä¢ Estado: Error obteniendo estad√≠sticas ({e})")
                
            # Info de presets
            print(f"\nüé® Presets disponibles:")
            print(f"  ‚Ä¢ Art√≠sticos: {len(ARTISTIC_PRESETS)}")
            print(f"  ‚Ä¢ Composiciones: {len(TEMPORAL_COMPOSITIONS)}")
            print(f"  ‚Ä¢ Estilos: {len(STYLE_CONFIGS)}")
            print(f"  ‚Ä¢ Funciones de trayectoria: {len(TRAJECTORY_FUNCTIONS)}")
            
        except Exception as e:
            logger.error(f"Error obteniendo info del sistema: {e}")
            print(f"\n‚ùå Error obteniendo informaci√≥n: {e}")
            
        await self._get_input("\nPresiona Enter para continuar...")
        
    # =====================================
    # M√âTODOS AUXILIARES
    # =====================================
    
    def _get_macro_name(self, macro_id: str) -> str:
        """Obtener nombre de un macro por ID"""
        for name, mid in self.macros.items():
            if mid == macro_id:
                return name
        return macro_id
        
    async def _get_input(self, prompt: str) -> str:
        """Obtener input del usuario"""
        return await asyncio.get_event_loop().run_in_executor(None, input, prompt)
        
    async def _get_int(self, prompt: str, min_val: int, max_val: int) -> int:
        """Obtener entero validado"""
        while True:
            try:
                val = int(await self._get_input(prompt))
                if min_val <= val <= max_val:
                    return val
                print(f"Por favor, ingrese un n√∫mero entre {min_val} y {max_val}")
            except ValueError:
                print("Por favor, ingrese un n√∫mero v√°lido")
                
    async def _get_float(self, prompt: str, min_val: float, max_val: float) -> float:
        """Obtener float validado"""
        while True:
            try:
                val = float(await self._get_input(prompt))
                if min_val <= val <= max_val:
                    return val
                print(f"Por favor, ingrese un n√∫mero entre {min_val} y {max_val}")
            except ValueError:
                print("Por favor, ingrese un n√∫mero v√°lido")
                
    async def _get_bool(self, prompt: str) -> bool:
        """Obtener booleano"""
        response = await self._get_input(prompt)
        return response.lower() in ['s', 'si', 's√≠', 'y', 'yes', '1', 'true']

       
# =====================================
# FUNCI√ìN PRINCIPAL
# =====================================


    """Funci√≥n principal"""
    controller = InteractiveController()
    await controller.start()


if __name__ == "__main__":
    print("")
üéÆ CONTROLADOR INTERACTIVO AVANZADO")
    print("Sistema completo de control de trayectorias")
    print("-"*60)
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("")

üëã ¬°Hasta luego!")
    except Exception as e:
        logging.error(f"Error fatal: {e}")
        print(f"")
‚ùå Error: {e}")