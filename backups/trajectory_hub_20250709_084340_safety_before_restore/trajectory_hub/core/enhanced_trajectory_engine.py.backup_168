"""
enhanced_trajectory_engine.py - Motor de trayectorias con sistema de componentes completo
Evolución de extended_path_engine.py que mantiene compatibilidad e integra motion_components
"""
from __future__ import annotations
import math
import numpy as np


try:
    # from rotation_system import ... # Archivo no existe
    pass
except ImportError:
    print('⚠️ rotation_system.py no encontrado')
    MacroRotation = None
import logging
import time
from typing import List, Dict, List, Optional, Callable, Set, Tuple, Any
from dataclasses import dataclass, field

# Importar el sistema de componentes
from trajectory_hub.core.motion_components import (
    MacroRotation,
    MotionDelta,
    SourceMotion,
    TrajectoryMovementMode,
    TrajectoryDisplacementMode,
    OrientationModulation,
    IndividualTrajectory,
    TrajectoryTransform,
    MacroTrajectory,
    MotionState,
    AdvancedOrientationModulation,
    ConcentrationComponent,
    ConcentrationMode,
    ConcentrationCurve,
    MacroRotation)
    # import continuation)
from trajectory_hub.core.trajectory_deformers import (
    CompositeDeformer, ForceFieldDeformation, WaveDeformation,

    ChaoticDeformation, GestureDeformation, BlendMode)

# Mantener compatibilidad con el sistema anterior
from trajectory_hub.core.extended_path_engine import (
    BoidParams, SourceInfo, MacroSource,
    _NUMBA_AVAILABLE, _BEHAVIORS_AVAILABLE)
    # import continuation
# from trajectory_hub.core.rotation_system import ... # Archivo no existe
    # import continuation
logger = logging.getLogger(__name__)


@dataclass
class EnhancedMacroSource(MacroSource):
    """Versión mejorada de MacroSource con soporte para el nuevo sistema"""

    # Campos base heredados de MacroSource
    name: str = ""
    behavior_name: str = "flock"

    # Componente de trayectoria macro
    trajectory_component: Optional[MacroTrajectory] = None
    
    # Configuración de trayectorias individuales
    individual_trajectories: Dict[int, str] = field(default_factory=dict)  # source_id: shape_type
    allow_different_trajectories: bool = False
    
    # Estado de concentración
    concentration_active: bool = False
    concentration_point: np.ndarray = field(default_factory=lambda: np.zeros(3))
    concentration_duration: float = 1.0
    
    # Deformador
    deformer: Optional[CompositeDeformer] = None
    deformation_enabled: bool = False

    def __post_init__(self):
        """Inicializar la clase padre MacroSource y configurar componentes"""
        # Inicializar los atributos de MacroSource de forma segura
        try:
            # Usar los valores por defecto si no están establecidos
            macro_id = getattr(self, 'id', f"macro_{id(self)}")
            name = getattr(self, 'name', f"Macro_{macro_id}")
            behavior = getattr(self, 'behavior_name', 'flock')
            
            # Llamar al constructor padre
            super().__init__(macro_id, name, behavior)
        except Exception as e:
            # Si hay algún problema, inicializar manualmente los atributos críticos
            logger.warning(f"Error en __post_init__: {e}. Inicializando manualmente.")
            if not hasattr(self, 'source_ids'):
                self.source_ids = []  # Lista, no set
        # Asegurar que trajectory_component se inicialice
        if self.trajectory_component is None:
            from trajectory_hub.core.motion_components import MotionDelta, MacroTrajectory
            self.trajectory_component = MacroTrajectory()


class EnhancedTrajectoryEngine:
    """
    Motor de trayectorias mejorado que integra el sistema de componentes
    Mantiene compatibilidad con la API anterior mientras añade nuevas capacidades
    """
    
    def __init__(self, max_sources: int = 64, fps: int = 60, 
                 params: Optional[BoidParams] = None,
                 use_legacy_mode: bool = False,
                 enable_modulator: bool = True):
        """Initialize the enhanced trajectory engine"""
        self.max_sources = max_sources
        self.fps = fps
        self.dt = 1.0 / fps
        self.params = params or BoidParams()
        self.use_legacy_mode = use_legacy_mode
        # Sistema de componentes nuevo
        self._source_motions: Dict[int, SourceMotion] = {}
        # Información de fuentes y macros (compatible con versión anterior)
        self._source_info: Dict[int, SourceInfo] = {}
        self._macros: Dict[str, EnhancedMacroSource] = {}
        # Estado interno
        self._time = 0.0
        self._frame_count = 0
        # Arrays para compatibilidad y optimización
        self._positions = np.zeros((max_sources, 3), dtype=np.float32)
        self._orientations = np.zeros((max_sources, 3), dtype=np.float32)
        self._apertures = np.ones(max_sources, dtype=np.float32) * 0.5
        # Sistema de deformadores global
        self.global_deformer = CompositeDeformer()
        # Deformadores por macro
        self._macro_deformers: Dict[str, CompositeDeformer] = {}
        # Sistema de modulación de orientación
        self.enable_modulator = enable_modulator
        self.orientation_modulators = {}  # Diccionario para guardar moduladores
        # Configuración global del modulador
        self.global_modulator_intensity = 1.0
        self.global_modulator_preset = None
        # Cache de últimas orientaciones enviadas
        self._last_orientations = {}
        self._orientation_update_threshold = 0.01
        # Cache de últimas aperturas enviadas
        self._last_apertures = {}
        self._aperture_update_threshold = 0.01  # Cambio mínimo para actualizar
        # Cache de últimas aperturas enviadas
        self._last_apertures = {}
        self._aperture_update_threshold = 0.01  # Cambio mínimo para actualizar  # radianes
        # OSC Bridge (se configura externamente)
        self.osc_bridge = None
        self._is_running = True
        logger.info(f"EnhancedTrajectoryEngine inicializado ({max_sources} fuentes @ {fps} fps)")
        # Diccionarios para tracking de cambios
        self._last_positions = {}
        self._last_orientations = {}
        self._last_apertures = {}
        self.time_paused = False
        # Sistema de rotación
        self.macro_rotations = {}
        self.trajectory_rotations = {}
        # Sistema de rotación algorítmica
        self.macro_rotations_algo = {}  # MacroRotation objects
        self.trajectory_rotations_algo = {}  # TrajectoryRotation objects
        self._rotation_time = 0.0  # Tiempo para las rotaciones algorítmicas
        self._macros = {}  # Almacén de macros
        self.motion_states = {}  # Dict[int, SourceMotion]
        # Conjunto de fuentes activas
        self._active_sources = set()
        def create_source(self, source_id: int, name: str = None):
        """
    Parameters
    ----------
    max_sources : int
    Número máximo de fuentes
    fps : int
    Frames por segundo
    params : BoidParams
    Parámetros de comportamiento boids
    use_legacy_mode : bool
    Si True, usa el comportamiento anterior (para compatibilidad)
    enable_modulator : bool
    Si True, habilita el sistema de modulación de orientación
    if source_id >= self.max_sources:
    raise ValueError(f"ID {source_id} excede el máximo de fuentes ({self.max_sources})")
        if source_id in self.motion_states:
    print(f"⚠️ Fuente {source_id} ya existe")
    return self.motion_states[source_id]
        # Crear estado inicial
    state = MotionState()
    state.source_id = source_id
    state.position = self._positions[source_id].copy()
    state.velocity = np.zeros(3)
    state.name = name or f"source_{source_id}"
        # Crear SourceMotion básico
    motion = SourceMotion(state)
    motion.source_id = source_id
        # Registrar
    self.motion_states[source_id] = motion
    self._active_sources.add(source_id)
        # Notificar al bridge OSC si existe
    print(f"✅ Fuente {source_id} creada: {state.name}")
    return motion
        def create_orientation_modulator(self, source_id: int) -> Optional[AdvancedOrientationModulation]:
    """Crea una nueva fuente de sonido"""
    if not self.enable_modulator:
    return None
        if source_id not in self._source_motions:
    logger.error(f"No se puede crear modulador para fuente inexistente {source_id}")
    return None
        # Crear modulador avanzado
    modulator = AdvancedOrientationModulation()
    modulator.source_id = source_id
        # Configurar con intensidad global
    modulator.intensity = self.global_modulator_intensity
        # Registrar
    self.orientation_modulators[source_id] = modulator
        logger.debug(f"Modulador de orientación creado para fuente {source_id}")
    return modulator
    return True
        def create_macro(
    self, 
    name: str, 
    source_count: int, 
    **kwargs):
    """
    """Crear modulador de orientación para una fuente"""
    # CORRECCIÓN: Flexibilidad para source_count
    if isinstance(source_count, list):
    actual_source_count = len(source_count)
    else:
    actual_source_count = source_count
            Crear un macro (grupo de fuentes)
        
        Parameters
        ----------
        name : str
            Nombre del macro
        source_count : int
            Número de fuentes en el macro
        behavior : str
            Tipo de comportamiento (flock, rigid, orbit, etc.)
        formation : str
            Formación inicial (circle, line, grid, spiral)
        spacing : float
            Espaciado entre fuentes
            
        Returns
        -------
        str
            ID del macro creado
        """
        # Generar ID único
        macro_id = f"macro_{len(self._macros)}_{name.lower().replace(' ', '_')}"
        
        # Crear conjunto de fuentes
        source_ids = []
        start_id = len(self._source_motions)
        
        for i in range(actual_source_count):
            sid = start_id + i
            if sid < self.max_sources:
                self.create_source(sid, f"{name}_{i}")
                source_ids.append(sid)
        
        # Crear macro con los campos necesarios
        macro = EnhancedMacroSource()
        
        # Establecer campos base
        macro.id = macro_id
        macro.name = name
        macro.behavior_name = behavior
        
        # Establecer campos opcionales
        if 'allow_different_trajectories' in kwargs:
            macro.allow_different_trajectories = kwargs['allow_different_trajectories']
        
        # Añadir fuentes al macro
        for sid in source_ids:
            macro.add_source(sid)
            if sid in self._source_info:
                self._source_info[sid].macro_id = macro_id
                
        # Crear componente de trayectoria macro
        macro.trajectory_component = MacroTrajectory()
        
        # Calcular posiciones según formación
        positions = []
        
        if formation == 'circle':
            for i in range(source_count):
                angle = (i / source_count) * 2 * np.pi
                x = spacing * np.cos(angle)
                y = spacing * np.sin(angle)
                positions.append(np.array([x, y, 0.0]))
                
        elif formation == 'line':
            for i in range(source_count):
                x = (i - source_count/2) * spacing
                positions.append(np.array([x, 0.0, 0.0]))
                
        elif formation == 'grid':
            cols = int(np.ceil(np.sqrt(source_count)))
            for i in range(source_count):
                row = i // cols
                col = i % cols
                x = (col - cols/2) * spacing
                y = (row - cols/2) * spacing
                positions.append(np.array([x, y, 0.0]))
                
        elif formation == 'square':
            # Cuadrado - distribuir en los bordes
            side_length = int(np.ceil(source_count / 4))
            for i in range(source_count):
                if i < side_length::
                    x = (i - side_length/2) * spacing
                    y = spacing * side_length/2
                elif i < 2 * side_length:  # Lado derecho
                    x = spacing * side_length/2
                    y = (side_length/2 - (i - side_length)) * spacing
                elif i < 3 * side_length:  # Lado inferior
                    x = (side_length/2 - (i - 2*side_length)) * spacing
                    y = -spacing * side_length/2
                else:  # Lado izquierdo
                    x = -spacing * side_length/2
                    y = ((i - 3*side_length) - side_length/2) * spacing
                positions.append(np.array([x, y, 0.0]))
                
        else:  # Default o formaciones no implementadas
            # Círculo por defecto
            for i in range(source_count):
                angle = (i / source_count) * 2 * np.pi
                x = spacing * np.cos(angle)
                y = spacing * np.sin(angle)
                positions.append(np.array([x, y, 0.0]))
        
        # Aplicar posiciones a las fuentes
        for i, (sid, pos) in enumerate(zip(source_ids, positions)):
            self._positions[sid] = pos
            if sid in self.motion_states:
                self.motion_states[sid].state.position = pos.copy()
        # Registrar macro
        self._macros[macro_id] = macro

        # IMPORTANTE: Añadir trajectory_component a cada fuente

        
        logger.info(f"Macro '{name}' creado con {len(source_ids)} fuentes")
        
        # Crear moduladores de orientación si está habilitado
        if self.enable_modulator:
            for i, sid in enumerate(source_ids):
                modulator = self.create_orientation_modulator(sid)
                if modulator:
                    # Desfase temporal para efecto orgánico
                    modulator.time_offset = i * 0.05
                
        # Si hay un preset global configurado, aplicarlo
        if self.global_modulator_preset:
            self.apply_orientation_preset(macro_id, self.global_modulator_preset)
            
        return self._macros[macro_id]

    def _apply_formation(self, source_ids: List[int], formation: str, spacing: float):
        """Aplicar formación inicial a un conjunto de fuentes"""
        total = len(source_ids)
        
        if total == 0:
            return
            
        # Centro de la formación (alrededor del listener)
        center = np.array([0.0, 0.0, 0.0])
        
        for index, sid in enumerate(source_ids):
            if sid not in self._source_motions:
                continue
                
            motion = self._source_motions[sid]
            
            # Calcular posición según formación
            if formation == "circle":
                angle = (index / total) * 2 * np.pi
                x = center[0] + spacing * np.cos(angle)
                y = center[1] + spacing * np.sin(angle)
                z = center[2]
            elif formation == "line":
                # Línea horizontal centrada
                x = center[0] + (index - total/2) * spacing
                y = center[1]
                z = center[2]
                
            elif formation == "grid":
                # Grid cuadrado
                grid_size = int(np.ceil(np.sqrt(total)))
                row = index // grid_size
                col = index % grid_size
                x = center[0] + (col - grid_size/2) * spacing
                y = center[1] + (row - grid_size/2) * spacing
                z = center[2]
                
            elif formation == "spiral":
                # Espiral de Arquímedes con elevación 3D
                turns = 3  # Número de vueltas
                max_radius = spacing * np.sqrt(total)
                t = index / total
                angle = t * turns * 2 * np.pi
                radius = t * max_radius
                
                # Coordenadas x, y (espiral horizontal)
                x = center[0] + radius * np.cos(angle)
                y = center[1] + radius * np.sin(angle)
                
                # CORRECCIÓN QUIRÚRGICA: Elevación z variable
                z_height = spacing * 0.5  # Amplitud basada en spacing
                z_frequency = 2.0  # Frecuencia de oscilación
                z = center[2] + z_height * np.sin(z_frequency * angle)
                

            else:
                # Por defecto, círculo
                angle = (index / total) * 2 * np.pi
                x = center[0] + spacing * np.cos(angle)
                y = center[1] + spacing * np.sin(angle)
                z = center[2]
            
            # Establecer posición inicial
            position = np.array([x, y, z])
            motion.state.position = position
            motion.state.velocity = np.zeros(3)
            
            # Guardar posición de formación como base
            if 'individual_trajectory' in motion.components:
                motion.components['individual_trajectory'].base_position = position.copy()
            motion.state.acceleration = np.zeros(3)
            
                        # CORRECCIÓN: Actualizar también _positions array para consistencia
            self._positions[sid] = position
            
            # Actualizar source_info
            if sid in self._source_info:
                self._source_info[sid].position = position
                
            logger.debug(f"Fuente {sid} posicionada en {position} (formación {formation})")
        
        # ===== PARCHE DE DEBUG =====
        # DEBUG: Mostrar posiciones Z después de aplicar formación
        if formation == "spiral":
            print(f"\n🔍 DEBUG SPIRAL - Posiciones Z aplicadas:")
            z_values = []
            for idx, sid in enumerate(source_ids[:5]):  # Solo primeros 5
                if sid in self._source_motions:
                    pos = self._source_motions[sid].state.position
                    z_values.append(pos[2])
                    print(f"   Fuente {sid}: x={pos[0]:.3f}, y={pos[1]:.3f}, z={pos[2]:.6f}")
            
            if z_values:
                z_range = max(z_values) - min(z_values)
                print(f"   📊 Rango Z: {z_range:.6f}")
                if z_range > 0.001:
                    print(f"   ✅ CORRECTO: Fuentes tienen diferentes alturas Z")
                else:
                    print(f"   ❌ PROBLEMA: Todas las fuentes tienen la misma altura Z")
            
            # DEBUG adicional: Verificar _positions array
            print(f"\n🔍 DEBUG _positions array:")
            for idx, sid in enumerate(source_ids[:3]):
                if sid in self._positions:
                    pos_array = self._positions[sid]
                    print(f"   _positions[{sid}]: z={pos_array[2]:.6f}")
        # ===== FIN PARCHE DE DEBUG =====
    def set_individual_trajectory(self, macro_id, source_id: int,
                                  shape: str, shape_params: dict = None,
                                  movement_speed: float = 1.0):
        """Configurar trayectoria individual para una fuente"""
        # Manejar tanto string como objeto macro
        if hasattr(macro_id, "name":  # Es un objeto EnhancedMacroSource):
            macro_name = macro_id.name
            macro = macro_id
        else:  # Es un string
            macro_name = macro_id
            if macro_name not in self._macros:
                print(f"⚠️ Macro '{macro_name}' no encontrado")
                return
            macro = self._macros[macro_name]
        
        if macro_id not in self._macros:
            raise ValueError(f"Macro '{macro_id}' not found")
        
        macro = self._macros[macro_id]
        
        # Verificar que la fuente pertenece al macro
        if source_id not in macro.source_ids:
            raise ValueError(f"Source {source_id} not in macro '{macro_id}'")
        
        # Verificar que el motion_state existe
        if source_id not in self.motion_states:
            raise ValueError(f"Motion state for source {source_id} not found")
        
        motion = self.motion_states[source_id]
        
        # Crear el componente de trayectoria individual
        from .motion_components import IndividualTrajectory
        
        # Crear el componente sin parámetros (constructor vacío)
        trajectory = IndividualTrajectory()
        
        # Configurar usando los métodos/atributos disponibles
        # IMPORTANTE: Inicializar shape_params
        trajectory.shape_params = shape_params if shape_params is not None else {}
        
        trajectory.shape = shape
        trajectory.movement_mode = movement_mode
        trajectory.movement_speed = speed
        trajectory.enabled = True
        
        # Configurar parámetros de forma
        if shape_params is None:
            shape_params = {}
        
        # Aplicar parámetros según la forma
        if shape == "circle":
            trajectory.radius = shape_params.get('radius', 2.0)
        elif shape == "spiral":
            trajectory.scale = shape_params.get('scale', 1.0)
            trajectory.turns = shape_params.get('turns', 3)
        elif shape == "figure8":
            trajectory.scale = shape_params.get('scale', 1.0)
        elif shape == "lissajous":
            trajectory.freq_x = shape_params.get('freq_x', 2)
            trajectory.freq_y = shape_params.get('freq_y', 3)
            trajectory.scale = shape_params.get('scale', 1.0)
        
        # Si tiene método configure, usarlo
        # Si tiene método set_shape, usarlo
        # Añadir a los componentes activos
        else:
            motion.active_components = {'individual_trajectory': trajectory}
        
        print(f"✅ Trayectoria individual configurada para fuente {source_id} en macro '{macro_id}'")
        return True
    def set_macro_trajectory(
        # Manejar tanto string como objeto macro
        if hasattr(macro_id, "name")::
    """Establecer trayectoria de un macro completo"""
    if macro_id not in self._macros:
    logger.error(f"Macro {macro_id} no existe")
    return
        macro = self._macros[macro_id]
        # Configurar componente de trayectoria
    if macro.trajectory_component:
    macro.trajectory_component.set_trajectory(trajectory_func, orientation_func)
    macro.trajectory_component.enabled = True
        # Habilitar deformación si se solicita
    macro.deformation_enabled = enable_deformation
        logger.info(f"Trayectoria establecida para macro {macro_id}")
            def set_macro_rotation(self, macro_name, speed_x=0.0, speed_y=0.0, speed_z=0.0, center=None):
    """Configura rotación algorítmica para un macro con sistema de deltas"""
            macro_name = macro_id.name
            macro = macro_id
        else:  # Es un string
            macro_name = macro_id
            if macro_name not in self._macros:
                print(f"⚠️ Macro '{macro_name}' no encontrado")
                return
            macro = self._macros[macro_name]
        
        self,
        macro_id: str,
        trajectory_func: Callable[[float], np.ndarray],
        orientation_func: Optional[Callable[[float], np.ndarray]] = None,
        enable_deformation: bool = True
    :
        # Manejar tanto string como objeto macro
        if hasattr(macro_id, "name")::
            macro_name = macro_id.name
            macro = macro_id
        else:  # Es un string
            macro_name = macro_id
            if macro_name not in self._macros:
                print(f"⚠️ Macro '{macro_name}' no encontrado")
                return
            macro = self._macros[macro_name]
        
        if macro_name not in self._macros:
            print(f"❌ Macro '{macro_name}' no existe")
            return False
            
        macro = self._macros[macro_name]
        source_ids = list(macro.source_ids)
        
        # Centro por defecto es el centroide del macro
        if center is None:
            positions = []
            for sid in source_ids:
                if sid < len(self._positions):
                    positions.append(self._positions[sid].copy())
            if positions:
                center = np.mean(positions, axis=0)
            else:
                center = np.array([0.0, 0.0, 0.0])
        
        # Convertir center a array numpy si no lo es
        center = np.array(center, dtype=np.float32)
        
        # Configurar rotación para cada fuente del macro
        configured = 0
        for sid in source_ids:
            if sid in self.motion_states:
                motion = self.motion_states[sid]
                
                # Crear componente si no existe
                if 'macro_rotation' not in motion.active_components:
                    rotation = MacroRotation()
                    motion.active_components['macro_rotation'] = rotation
                else:
                    rotation = motion.active_components['macro_rotation']
                
                # Configurar rotación
                # Configurar rotación directamente
                rotation.speed_x = speed_x
                rotation.speed_y = speed_y
                rotation.speed_z = speed_z
                if center is not None:
                    rotation.center = center
                rotation.enabled = (
                    abs(float(speed_x)) > 0.001 or
                    abs(float(speed_y)) > 0.001 or
                    abs(float(speed_z)) > 0.001
                
                configured += 1
        
        if configured > 0:
            print(f"✅ Rotación configurada para '{macro_name}'")
            print(f"   Centro: [{center[0]:.2f}, {center[1]:.2f}, {center[2]:.2f}]")
            print(f"   Velocidades: X={float(speed_x):.2f}, Y={float(speed_y):.2f}, Z={float(speed_z):.2f} rad/s")
            print(f"   Fuentes: {configured}/{len(source_ids)}")
            return True
        
        return False


    def set_manual_macro_rotation(self, macro_id: str, pitch: float = None, 
                                 yaw: float = None, roll: float = None,
                                 center: np.ndarray = None):
    """
    if macro_id not in self._macros:
    print(f"Macro '{macro_id}' no encontrado")
    return False
        macro = self._macros[macro_id]
        def set_individual_rotation(self, source_id, speed_x=0.0, speed_y=0.0, speed_z=0.0, center=None):
        """Configurar rotación algorítmica individual"""
        """
        Configura rotación manual para un macro
        
        Args:
            macro_id: ID del macro
            pitch: Ángulo de pitch en radianes
            yaw: Ángulo de yaw en radianes
            roll: Ángulo de roll en radianes
            interpolation_speed: Velocidad de interpolación (0-1)
            center: Centro de rotación [x,y,z]
        if source_id not in self.motion_states:
            print(f"⚠️ Fuente {source_id} no existe")
            return
        
        motion = self.motion_states[source_id]
        
        # Crear componente de rotación
        from trajectory_hub.core.motion_components import IndividualRotation
        rotation = IndividualRotation()
        rotation.speed_x = speed_x
        rotation.speed_y = speed_y
        rotation.speed_z = speed_z
        rotation.center = center if center is not None else np.array([0.0, 0.0, 0.0])
        
        # Añadir a componentes activos
        motion.active_components["individual_rotation"] = rotation
        
        print(f"✅ Rotación individual configurada para fuente {source_id}")
        print(f"   Velocidades: X={speed_x:.2f}, Y={speed_y:.2f}, Z={speed_z:.2f} rad/s")
    def set_manual_individual_rotation(self, source_id: int,
                                     yaw: float = 0.0, pitch: float = 0.0, roll: float = 0.0,) center: Optional[List[float]] = None -> bool):
    """
    if source_id not in self.motion_states:
    print(f"❌ Fuente {source_id} no existe")
    return False
        motion = self.motion_states[source_id]
        # Determinar centro
    if center is None:
    center = self._positions[source_id].copy()
    else:
    center = np.array(center, dtype=np.float32)
        # Crear o actualizar componente
    from trajectory_hub.core.motion_components import ManualIndividualRotation
        if 'manual_individual_rotation' in motion.active_components:
    # Actualizar existente
    rotation = motion.active_components['manual_individual_rotation']
    rotation.center = center
    rotation.set_target_rotation(yaw, pitch, roll, interpolation_speed)
    # Sincronizar con estado actual
    rotation._sync_with_state(motion.state)
    else:
    # Crear nuevo
    rotation = ManualIndividualRotation()
    rotation.set_target_rotation(yaw, pitch, roll, interpolation_speed)
    rotation._sync_with_state(motion.state)
    motion.active_components['manual_individual_rotation'] = rotation
        print(f"✅ Rotación manual configurada para fuente {source_id}")
    print(f"   Objetivos: Yaw={math.degrees(yaw):.1f}°, Pitch={math.degrees(pitch):.1f}°, Roll={math.degrees(roll):.1f}°")
        return True
        def stop_individual_rotation(self, source_id: int, rotation_type: str = 'both') -> bool:
    """
    Configura rotación manual con interpolación para una fuente individual
        Args:
    source_id: ID de la fuente
    yaw: Rotación objetivo en Y (radianes)
    pitch: Rotación objetivo en X (radianes)
    roll: Rotación objetivo en Z (radianes)
    interpolation_speed: Velocidad de interpolación (0.01 a 1.0)
    center: Centro de rotación (opcional, default: posición actual)
        Returns:
    True si se configuró correctamente
    Detiene la rotación de una fuente individual
        Args:
    source_id: ID de la fuente
    rotation_type: 'algorithmic', 'manual', o 'both'
        Returns:
    True si se detuvo correctamente
    """
    """
        if source_id not in self.motion_states:
            print(f"❌ Fuente {source_id} no existe")
            return False
        
        motion = self.motion_states[source_id]
        stopped = False
        
        if rotation_type in ['algorithmic', 'both']:
            if 'individual_rotation' in motion.active_components:
                motion.active_components['individual_rotation'].enabled = False
                print(f"✅ Rotación algorítmica detenida para fuente {source_id}")
                stopped = True
        
        if rotation_type in ['manual', 'both']:
            if 'manual_individual_rotation' in motion.active_components:
                motion.active_components['manual_individual_rotation'].enabled = False
                print(f"✅ Rotación manual detenida para fuente {source_id}")
                stopped = True
        
        return stopped
    
    def set_batch_individual_rotation(self, source_ids: List[int], 
                                    speed_x: float = 0.0, speed_y: float = 0.0, speed_z: float = 0.0,) offset_factor: float = 0.0 -> int):
    """
    configured = 0
        for i, sid in enumerate(source_ids):
    # Aplicar desfase si se especifica
    factor = 1.0 + (i * offset_factor)
    sx = speed_x * factor
    sy = speed_y * factor
    sz = speed_z * factor
        if self.set_individual_rotation(sid, sx, sy, sz):
    configured += 1
        print(f"Rotacion configurada para {configured}/{len(source_ids)} fuentes")
    return configured
        # Importar la clase
    from .motion_components import ManualMacroRotation
        # Configurar para cada fuente del macro
    for source_id in macro.source_ids:
    if source_id not in self.motion_states:
    continue
        motion = self.motion_states[source_id]
        # Crear o actualizar el componente
    if 'manual_macro_rotation' not in motion.active_components:
    rotation = ManualMacroRotation()
    motion.active_components['manual_macro_rotation'] = rotation
    else:
    rotation = motion.active_components['manual_macro_rotation']
        # Configurar parámetros
    rotation.set_target_rotation(pitch, yaw, roll)
    rotation.set_interpolation_speed(interpolation_speed)
        if center is not None:
    rotation.center = center.copy()
    else:
    # Usar el centro del macro
    positions = [self._positions[sid] for sid in macro.source_ids 
    if sid < len(self._positions)]
    if positions:
    rotation.center = np.mean(positions, axis=0)
        rotation.enabled = True
        print(f"✅ Rotación manual configurada para macro '{macro_id}'")
    return True
        def toggle_manual_macro_rotation(self, macro_id: str, enabled: bool = None):
    """
    Configura rotación algorítmica para múltiples fuentes con desfase opcional
        Args:
    source_ids: Lista de IDs de fuentes
    speed_x: Velocidad base en X (rad/s)
    speed_y: Velocidad base en Y (rad/s)
    speed_z: Velocidad base en Z (rad/s)
    offset_factor: Factor de desfase entre fuentes (0.0 = sin desfase)
        Returns:
    Número de fuentes configuradas exitosamente
    if macro_id not in self._macros:
    return False
        macro = self._macros[macro_id]
        for source_id in macro.source_ids:
    if source_id in self.motion_states:
    motion = self.motion_states[source_id]
    if 'manual_macro_rotation' in motion.active_components:
    comp = motion.active_components['manual_macro_rotation']
    if enabled is None:
    comp.enabled = not comp.enabled
    else:
    comp.enabled = enabled
        return True
        def set_macro_speed(self, macro_id: str, speed: float):
    """
    """
    """Activa/desactiva la rotación manual de un macro"""
    Establecer velocidad global de un macro
        Parameters
    ----------
    macro_id : str
    ID del macro
    speed : float
    Factor de velocidad (1.0 = normal, 2.0 = doble, 0.5 = mitad)
        if macro_id not in self._macros:
            logger.error(f"Macro {macro_id} no existe")
            return
            
        macro = self._macros[macro_id]
        
        # Establecer velocidad en el macro
        macro.trajectory_speed = speed
        
        # Aplicar velocidad a componente de trayectoria si existe
        # Aplicar velocidad a todas las fuentes del macro si tienen trayectorias individuales
        logger.info(f"Velocidad {speed:.2f}x aplicada al macro {macro_id}")


    def set_trajectory_rotation(self, source_id: int, pitch: float, yaw: float, roll: float):
    """
    if source_id not in self._source_motions:
    logger.warning(f"Fuente {source_id} no encontrada")
    return
        # Crear diccionario si no existe
    # Guardar rotación para aplicar en update
    self.trajectory_rotations[source_id] = {
    'pitch': pitch,
    'yaw': yaw,
    'roll': roll,
    'matrix': self._calculate_rotation_matrix(pitch, yaw, roll)
    }
        # Aplicar inmediatamente si hay una trayectoria individual
    motion = self._source_motions[source_id]
    traj = motion.components.get('individual_trajectory')
    if traj:
    # Guardar la matriz de rotación en el componente
    traj.rotation_matrix = self.trajectory_rotations[source_id]['matrix']
        # Si la trayectoria tiene set_rotation, usarlo
        logger.info(f"Rotación manual establecida para trayectoria {source_id}: "
    f"pitch={np.degrees(pitch):.1f}°, "
    f"yaw={np.degrees(yaw):.1f}°, "
    f"roll={np.degrees(roll:.1f}°")
            def _calculate_rotation_matrix(self, pitch: float, yaw: float, roll: float):
    """
    Establece la rotación manual de una trayectoria individual
        Parameters
    ----------
    source_id : int
    ID de la fuente
    pitch : float
    Rotación en X (radianes)
    yaw : float
    Rotación en Y (radianes)
    roll : float
    Rotación en Z (radianes)
    Calcular matriz de rotación 3x3 desde ángulos de Euler
        Parameters
    ----------
    pitch : float
    Rotación alrededor del eje X (radianes)
    yaw : float
    Rotación alrededor del eje Y (radianes)
    roll : float
    Rotación alrededor del eje Z (radianes)
        Returns
    -------
    np.ndarray
    Matriz de rotación 3x3
    """
    """
        # Rotación X (pitch)
        cx, sx = np.cos(pitch), np.sin(pitch)
        rx = np.array([[1, 0, 0], [0, cx, -sx], [0, sx, cx]])
        
        # Rotación Y (yaw)  
        cy, sy = np.cos(yaw), np.sin(yaw)
        ry = np.array([[cy, 0, sy], [0, 1, 0], [-sy, 0, cy]])
        
        # Rotación Z (roll)
        cz, sz = np.cos(roll), np.sin(roll)
        rz = np.array([[cz, -sz, 0], [sz, cz, 0], [0, 0, 1]])
        
        # Matriz combinada: R = Rz * Ry * Rx
        return rz @ ry @ rx

    def set_individual_rotation(self, source_id: int, speed_x=0.0, speed_y=0.0, speed_z=0.0, center=None):
        """Configurar rotación algorítmica individual con deltas"""
        if source_id not in self.motion_states:
            print(f"⚠️ Fuente {source_id} no existe")
            return
        
        motion = self.motion_states[source_id]
        
        # Importar aquí para evitar imports circulares
        from trajectory_hub.core.motion_components import IndividualRotation
        
        # Crear componente de rotación
        rotation = IndividualRotation()
        rotation.speed_x = float(speed_x)
        rotation.speed_y = float(speed_y)
        rotation.speed_z = float(speed_z)
        rotation.center = center if center is not None else np.zeros(3)
        rotation.enabled = True
        
        # Añadir a componentes activos
        motion.active_components["individual_rotation"] = rotation
        
        print(f"✅ Rotación individual configurada para fuente {source_id}")
        print(f"   Velocidades: X={speed_x:.2f}, Y={speed_y:.2f}, Z={speed_z:.2f} rad/s")
    
    def rotate_individual_batch(self, source_ids: List[int], pitch: float = 0.0, yaw: float = 0.0, roll: float = 0.0):
    """
    for sid in source_ids:
    self.set_individual_rotation(sid, pitch, yaw, roll)
        def _apply_macro_rotation(self, macro_name: str):
    """Aplicar la rotación a todas las fuentes del macro"""
        """
        Aplicar la misma rotación a múltiples trayectorias individuales
        
        Parameters
        ----------
        source_ids : List[int]
            Lista de IDs de fuentes
        pitch, yaw, roll : float
            Ángulos de rotación en radianes
        if macro_name not in self._macros or macro_name not in self.macro_rotations:
            return
        
        macro = self._macros[macro_name]
        rotation_matrix = self.macro_rotations[macro_name]
        
        # Calcular el centro del macro
        positions = []
        for sid in macro.source_ids:
            if sid in self._positions:
                positions.append(self._positions[sid])
        
        if not positions:
            return
        
        center = np.mean(positions, axis=0)
        
        # Rotar cada fuente alrededor del centro
        for sid in macro.source_ids:
            if sid in self._source_motions:
                motion = self._source_motions[sid]
                
                # Posición relativa al centro
                rel_pos = motion.state.position - center
                
                # Aplicar rotación
                rotated_pos = rotation_matrix @ rel_pos
                
                # Nueva posición absoluta
                motion.state.position = center + rotated_pos
                self._positions[sid] = motion.state.position.copy()
    def set_mixed_trajectories(self, macro_id: str, shape_distribution: List[Tuple[str, float]]):
    """
    if macro_id not in self._macros:
    logger.error(f"Macro {macro_id} no existe")
    return
        macro = self._macros[macro_id]
    macro.allow_different_trajectories = True
        source_list = list(macro.source_ids)
    total = len(source_list)
        # Asignar formas según distribución
    current_idx = 0
    for shape, proportion in shape_distribution:
    count = int(total * proportion)
    for i in range(count):
    if current_idx < total:
    sid = source_list[current_idx]
    macro.individual_trajectories[sid] = shape
        # Configurar la trayectoria individual
    if sid in self._source_motions:
    motion = self._source_motions[sid]
    traj = motion.components.get('individual_trajectory')
    if isinstance(traj, IndividualTrajectory):
    traj.shape_type = shape
    traj.set_trajectory(shape)
        current_idx += 1
        logger.info(f"Trayectorias mixtas asignadas a macro {macro_id}")
        def apply_breathing(self, period: float = 5.0, amplitude: float = 1.0, 
    macro_id: Optional[str] = None):
    """
    Asignar diferentes formas de trayectoria a las fuentes de un macro
        Parameters
    ----------
    macro_id : str
    ID del macro
    shape_distribution : List[Tuple[str, float]]
    Lista de (forma, proporción) donde proporción suma 1.0
    if macro_id:
    if macro_id not in self._macro_deformers:
    self._macro_deformers[macro_id] = CompositeDeformer()
    deformer = self._macro_deformers[macro_id]
    else:
    deformer = self.global_deformer
        # Crear deformación de respiración
    breathing = WaveDeformation(
    wave_type="sine",
    frequency=1.0 / period,
    amplitude=amplitude,
    phase=0.0
        breathing.scale_mode = True  # Modo escala
        deformer.add_deformation("breathing", breathing)
    logger.info(f"Respiración aplicada: período={period}s, amplitud={amplitude}")
        def apply_concentration(self, macro_id: str, point: np.ndarray, duration: float = 2.0):
    """
    """
    """Aplicar efecto de respiración (expansión/contracción)"""
    Aplicar concentración temporal hacia un punto
        Parameters
    ----------
    macro_id : str
    ID del macro
    point : np.ndarray
    Punto de concentración
    duration : float
    Duración de la transición
        if macro_id not in self._macros:
            return
            
        macro = self._macros[macro_id]
        macro.concentration_active = True
        macro.concentration_point = point.copy()
        macro.concentration_duration = duration
        
        # Aplicar a cada fuente del macro
        start_time = self._time
        for sid in macro.source_ids:
            if sid not in self._source_motions:
                continue
                
            motion = self._source_motions[sid]
            transform = motion.components.get('trajectory_transform')
            
            if isinstance(transform, TrajectoryTransform):
                # Función de interpolación temporal
                initial_offset = transform.offset.copy() if isinstance(transform.offset, np.ndarray) else np.zeros(3)
                target_offset = point - motion.state.position
                
                def concentration_func(t):
                    elapsed = t - start_time
                    if elapsed >= duration:
                        return target_offset
                    factor = elapsed / duration
                    # Ease in-out
                    factor = 0.5 * (1 - np.cos(np.pi * factor))
                    return initial_offset + (target_offset - initial_offset) * factor
                    
                transform.offset = concentration_func
                transform.enabled = True


    # =========== SISTEMA DE CONCENTRACIÓN ===========
    
    def set_macro_concentration(self, macro_name: str, factor: float = 0.5):
        """Aplica concentración usando sistema de deltas"""
        # Manejar tanto string como objeto macro
        if hasattr(macro_id, "name")::
            macro_name = macro_id.name
            macro = macro_id
        else:  # Es un string
            macro_name = macro_id
            if macro_name not in self._macros:
                print(f"⚠️ Macro '{macro_name}' no encontrado")
                return
            macro = self._macros[macro_name]
        
        # Buscar el macro
        full_name = None
        for name in self._macros.keys():
            if name.endswith(f"_{macro_name}") or name == macro_name:
                full_name = name
                break
                
        if not full_name:
            print(f"Macro {macro_name} no encontrado")
            return False
            
        macro = self._macros[full_name]
        print(f"Aplicando concentración a macro {full_name} con factor {factor}")
        macro.concentration_active = True
        
        # Crear/actualizar componente de concentración para cada fuente
        from trajectory_hub.core.motion_components import ConcentrationComponent
        
        for sid in macro.source_ids:
            # Asegurar que existe motion state
            if sid not in self.motion_states:
                from trajectory_hub.core.motion_components import SourceMotion
                self.motion_states[sid] = SourceMotion(sid)
            
            motion = self.motion_states[sid]
            
            # Buscar o crear componente de concentración
            concentration = None
            for comp in motion.active_components:
                if isinstance(comp, ConcentrationComponent):
                    concentration = comp
                    break
            
            if concentration is None:
                concentration = ConcentrationComponent()
                concentration.macro = macro
                concentration.enabled = True
                motion.add_component(concentration)
                print(f"   Añadido ConcentrationComponent a source {sid}")
            
            # Configurar
            concentration.enabled = True
            concentration.concentration_factor = factor
            concentration.macro_center = np.mean([self._positions[i] for i in macro.source_ids], axis=0)
            print(f"   Source {sid}: factor={factor}, centro={concentration.macro_center}")
        
        return True
    def animate_macro_concentration(self, macro_id: str, target_factor: float,
                                   duration: float = 2.0,) curve: str = "ease_in_out" -> bool):
        """Animar transición de concentración"""
        macro = self._macros.get(macro_id)
        if not macro:
            return False
            
        # Importar necesario
        from trajectory_hub.core.motion_components import MotionDelta, ConcentrationCurve
            
        # Convertir string a enum
        curve_enum = ConcentrationCurve[curve.upper().replace(" ", "_")]
        
        for sid in macro.source_ids:
            if sid in self._source_motions:
                concentration = self._source_motions[sid].components.get('concentration')
                if concentration:
                    concentration.animation_curve = curve_enum
                    
        return self.set_macro_concentration(macro_id, target_factor, duration)
        
    def get_macro_concentration_state(self, macro_id: str) -> Dict:
        """Obtener estado actual de concentración"""
        macro = self._macros.get(macro_id)
        if not macro or not macro.source_ids:
            return {"error": "Macro no encontrado"}
            
        # Obtener del primer source
        first_sid = next(iter(macro.source_ids))
        if first_sid not in self._source_motions:
            return {"error": "Source no encontrado"}
            
        concentration = self._source_motions[first_sid].components.get('concentration')
        if not concentration:
            return {
                "enabled": False,
                "factor": 1.0,
                "mode": "fixed_point",
                "animating": False
            }
            
        return {
            "enabled": concentration.enabled,
            "factor": concentration.factor,
            "mode": concentration.mode.value,
            "animating": concentration.animation_active,
            "target_point": concentration.target_point.tolist(),
            "include_macro_trajectory": concentration.include_macro_trajectory
        }
        
    def toggle_macro_concentration(self, macro_id: str) -> bool:
        """Alternar entre concentrado y disperso"""
        state = self.get_macro_concentration_state(macro_id)
        if state.get("error"):
            return False
            
        current_factor = state.get("factor", 1.0)
        target_factor = 0.0 if current_factor > 0.5 else 1.0
        
        return self.animate_macro_concentration(macro_id, target_factor, 2.0)
        
    def set_concentration_parameters(self, macro_id: str, **params) -> bool:
        """Configurar parámetros avanzados de concentración"""
        macro = self._macros.get(macro_id)
        if not macro:
            return False
            
        for sid in macro.source_ids:
            if sid in self._source_motions:
                concentration = self._source_motions[sid].components.get('concentration')
                if concentration:
                    for key, value in params.items():
                        if hasattr(concentration, key):
                            setattr(concentration, key, value)
                            
        return True

    def apply_dispersion(self, macro_id: str, force: float = 2.0, duration: float = 1.5):
        """Aplicar dispersión desde el centro"""
        if macro_id not in self._macros:
            return
            
        macro = self._macros[macro_id]
        
        # Calcular centro actual
        positions = []
        for sid in macro.source_ids:
            if sid in self._positions:
                positions.append(self._positions[sid])
                
        if not positions:
            return
            
        center = np.mean(positions, axis=0)
        
        # Aplicar fuerza de dispersión
        start_time = self._time
        for sid in macro.source_ids:
            if sid not in self._source_motions:
                continue
                
            motion = self._source_motions[sid]
            transform = motion.components.get('trajectory_transform')
            
            if isinstance(transform, TrajectoryTransform):
                # Dirección de dispersión
                direction = motion.state.position - center
                if np.linalg.norm(direction) > 0.001:
                    direction = direction / np.linalg.norm(direction)
                else:
                    # Dirección aleatoria si está en el centro
                    angle = np.random.uniform(0, 2 * np.pi)
                    direction = np.array([np.cos(angle), np.sin(angle), 0])
                    
                initial_offset = transform.offset.copy() if isinstance(transform.offset, np.ndarray) else np.zeros(3)
                target_offset = direction * force
                
                def dispersion_func(t):
                    elapsed = t - start_time
                    if elapsed >= duration:
                        return target_offset
                    factor = elapsed / duration
                    # Ease out
                    factor = 1.0 - (1.0 - factor) ** 2
                    return initial_offset + (target_offset - initial_offset) * factor
                    
                transform.offset = dispersion_func
                transform.enabled = True

    def apply_orientation_preset(self, macro_id: str, preset_name: str,
                                       intensity: float = 1.0, 
                                       time_offset_spread: float = 0.0):
        """
        Aplicar un preset de orientación a todas las fuentes de un macro
        
        Parameters
        ----------
        macro_id : str
            ID del macro
        preset_name : str
            Nombre del preset a aplicar
        intensity : float, optional
            Intensidad de la modulación (0.0-1.0), por defecto 1.0
        time_offset_spread : float, optional
            Desfase temporal entre fuentes en segundos, por defecto 0.0
            
        Returns
        -------
        bool
            True si se aplicó correctamente, False en caso de error
        """
        if macro_id not in self._macros:
            logger.error(f"Macro {macro_id} no encontrado")
            return False
            
        macro = self._macros[macro_id]
        
        for sid in macro.source_ids:
            if sid in self.orientation_modulators:
                modulator = self.orientation_modulators[sid]
                modulator.apply_preset(preset_name)
                logger.debug(f"Preset '{preset_name}' aplicado a fuente {sid}")
                
        logger.info(f"Preset de orientación '{preset_name}' aplicado a macro {macro_id}")

        return True

    def set_modulator_intensity(self, intensity: float, macro_id: Optional[str] = None):
        """Establecer intensidad del modulador (0-1)"""
        intensity = np.clip(intensity, 0.0, 1.0)
        
        if macro_id:
            # Aplicar solo a un macro
            if macro_id in self._macros:
                macro = self._macros[macro_id]
                for sid in macro.source_ids:
                    if sid in self.orientation_modulators:
                        self.orientation_modulators[sid].intensity = intensity
        else:
            # Aplicar globalmente
            self.global_modulator_intensity = intensity
            for modulator in self.orientation_modulators.values():
                modulator.intensity = intensity
                
        logger.info(f"Intensidad del modulador establecida a {intensity:.1%}")

    def update(self, dt: float = None) -> None:
        """Actualiza el sistema completo con soporte para deltas"""
        if dt is None:
            current_time = time.time()
            dt = current_time - self._last_time
            self._last_time = current_time
        else:
            current_time = self._last_time + dt
            self._last_time = current_time
        
        # Rate limiting
        if not self._check_rate_limit():
            return
        
        # 1. ACTUALIZAR COMPONENTES DE MOVIMIENTO (motion_states)
        for source_id, motion in self.motion_states.items():

            # Sincronizar state con position
            if source_id in self._active_sources:
                motion.state.position = self._positions[source_id].copy()
            if motion is not None:
                # Actualizar el SourceMotion con el tiempo actual
                # motion.update(current_time, dt)  # REEMPLAZADO
                # Usar update_with_deltas para obtener deltas
                # Obtener el estado actualizado
                state = motion.state
                
                # Actualizar posición en el array principal
                if source_id < len(self._positions):
                    self._positions[source_id] = state.position
                    
                    # Si hay orientación en el estado, actualizar también
        
        # 2. PROCESAR DELTAS (si está implementado)
        # 3. ACTUALIZAR MODULADORES DE ORIENTACIÓN
        if self.enable_modulator:
            for source_id, state in self.motion_states.items():
                if source_id in self.orientation_modulators:
                    modulator = self.orientation_modulators[source_id]
                    if modulator.enabled:
                        # Actualizar estado con modulación
                        state = modulator.update(current_time, dt, state)
                        self.motion_states[source_id].state = state
                        
                        # Actualizar arrays principales
                        if source_id < len(self._orientations):
                            self._orientations[source_id] = state.orientation
                        if source_id < len(self._apertures):
                            self._apertures[source_id] = state.aperture
        
        # 4. APLICAR FÍSICA Y OTROS SISTEMAS
        # ... (mantener código existente de física si existe)
        
        # 5. ENVIAR ACTUALIZACIONES OSC
        # self\.send_osc_update\(\)  # Temporalmente comentado
        
        # Incrementar contador de frames
        self._frame_count += 1
        self._time += dt


    def _prepare_osc_data(self):
        """Preparar datos para envío OSC en formato correcto"""
        active_sources = set()
        for macro in self._macros.values():
            active_sources.update(macro.source_ids)
        
        # Convertir a arrays numpy para OSC
        positions_list = []
        orientations_list = []
        apertures_list = []
        names_dict = {}
        
        for sid in sorted(active_sources):
            if sid in self._source_motions:
                # Posición
                pos = self._positions[sid]
                positions_list.append(pos.tolist() if hasattr(pos, 'tolist') else list(pos))
                
                # Orientación
                orient = self._orientations[sid]
                orientations_list.append(orient.tolist() if hasattr(orient, 'tolist') else list(orient))
                
                # Apertura
                apertures_list.append(float(self._apertures[sid]))
                
                # Nombre
                if sid in self._source_info:
                    names_dict[sid] = str(self._source_info[sid].name)
        
        return {
            'positions': positions_list,
            'orientations': orientations_list,
            'apertures': apertures_list,
            'names': names_dict,
            'count': len(positions_list)
        }

    def step(self) -> None:
        """Ejecuta un paso de simulación con soporte de deltas"""
        if not self.running:
            return
        
        current_time = time.time()
        dt = 1.0 / self.fps
        
        # Sistema de deltas para composición de movimientos
        all_deltas = []
        
        # Actualizar cada SourceMotion y recolectar deltas
        for source_id, motion in self.motion_states.items():
            if hasattr(motion, 'update_with_deltas'):
                deltas = motion.update_with_deltas(current_time, dt)
                if deltas:
                    all_deltas.extend(deltas)
        
        # Aplicar todos los deltas a las posiciones
        for delta in all_deltas:
            # No usar delta.source_id aquí - se procesa más adelante
                if delta.position is not None:
                    self._positions[delta.source_id] += delta.position
        
        # Llamar a update si existe para mantener compatibilidad


    def step(self) -> None:
        """Ejecuta un paso de simulación con soporte de deltas"""
        if not self.running:
            return
        
        current_time = time.time()
        dt = 1.0 / self.fps
        
        # Sistema de deltas para composición de movimientos
        all_deltas = []
        
        # Actualizar cada SourceMotion y recolectar deltas
        for source_id, motion in self.motion_states.items():
            if hasattr(motion, 'update_with_deltas'):
                deltas = motion.update_with_deltas(current_time, dt)
                if deltas:
                    all_deltas.extend(deltas)
        
        # Aplicar todos los deltas a las posiciones
        for delta in all_deltas:
            # No usar delta.source_id aquí - se procesa más adelante
                if delta.position is not None:
                    self._positions[delta.source_id] += delta.position
        
        # Llamar a update si existe para mantener compatibilidad


    def step(self) -> Dict[str, Any]:
    """
    return self.update()
        def get_debug_info(self, source_id: int) -> Dict[str, Any]:
    """
    Método de compatibilidad para InteractiveController
    Llama a update() y devuelve el estado
    if source_id not in self._source_motions:
    return {"error": "Fuente no encontrada"}
        motion = self._source_motions[source_id]
    info = {
    "id": source_id,
    "position": motion.state.position.tolist(),
    "orientation": motion.state.orientation.tolist(),
    "aperture": motion.state.aperture,
    "components": {}
    }
        for name, component in motion.components.items():
    comp_info = {
    "enabled": component.enabled,
    "weight": component.weight
    }
        if isinstance(component, IndividualTrajectory):
    comp_info.update({
    "shape": component.shape_type,
    "movement_mode": component.movement_mode.value,
    "position_on_trajectory": component.position_on_trajectory
    }
    elif isinstance(component, TrajectoryTransform):
    comp_info.update({
    "displacement_mode": component.displacement_mode.value,
    "offset": component.offset.tolist() if isinstance(component.offset, np.ndarray) else str(component.offset)
    }
    elif isinstance(component, OrientationModulation):
    comp_info.update({
    "has_yaw": component.yaw_func is not None,
    "has_pitch": component.pitch_func is not None,
    "has_roll": component.roll_func is not None
    }
        info["components"][name] = comp_info
        return info
        # ========== MÉTODOS DE COMPATIBILIDAD ==========
        def set_source_name(self, source_id: int, name: str):
    """Obtener información de debug de una fuente"""
    if source_id in self._source_info:
    self._source_info[source_id].name = name
    else:
    logger.warning(f"Fuente {source_id} no existe para establecer nombre")
        def get_source_names(self) -> Dict[int, str]:
    """Compatibilidad: establecer nombre de fuente"""
    return {sid: info.name for sid, info in self._source_info.items() if info.name}
        def get_deformer(self, macro_id: Optional[str] = None) -> CompositeDeformer:
    """
    """
    """Compatibilidad: obtener nombres de fuentes"""
    Obtener deformador para un macro o el global
        Parameters
    ----------
    macro_id : str, optional
    ID del macro. Si None, retorna el deformador global
        Returns
    -------
    CompositeDeformer
    Deformador solicitado
        if macro_id:
            if macro_id not in self._macro_deformers:
                self._macro_deformers[macro_id] = CompositeDeformer()
            return self._macro_deformers[macro_id]
        return self.global_deformer

    def save_modulator_state(self, macro_name: str) -> Dict[str, Any]:
        """Guardar estado de los moduladores de un macro"""
        if macro_name not in self._macros:
            logger.error(f"Macro '{macro_name}' no encontrado")
            return {}
            
        macro = self._macros[macro_name]
        state = {}
        
        for sid in macro.source_ids:
            if sid in self.orientation_modulators:
                state[sid] = self.orientation_modulators[sid].get_state_dict()
                
        logger.info(f"Estado de moduladores guardado para macro '{macro_name}'")
        return state

    def load_modulator_state(self, macro_name: str, state: Dict[str, Any]) -> bool:
        """Cargar estado de los moduladores de un macro"""
        if macro_name not in self._macros:
            logger.error(f"Macro '{macro_name}' no encontrado")
            return False
            
        macro = self._macros[macro_name]
        
        for sid, mod_state in state.items():
            sid = int(sid)  # Asegurar que es int
            if sid not in macro.source_ids:
                continue
                
            if sid not in self.orientation_modulators:
                self.create_orientation_modulator(sid)
                
            self.orientation_modulators[sid].load_state_dict(mod_state)
            
        logger.info(f"Estado de moduladores cargado para macro '{macro_name}'")
        return True


    def get_orientation_presets(self) -> Dict[str, Dict[str, Any]]:
    """
    # Importar la clase si no está importada
    try:
    from trajectory_hub.core.motion_components import MotionDelta, AdvancedOrientationModulation
    except ImportError:
    from motion_components import AdvancedOrientationModulation
        # Crear una instancia temporal para acceder a los presets
    temp_modulator = AdvancedOrientationModulation()
    presets = temp_modulator.presets
        # Formatear para el usuario
    formatted_presets = {}
    for name, data in presets.items():
    formatted_presets[name] = {
    "description": data["description"],
    "shape": data["shape"],
    "lfo": data["lfo"],
    "aperture": data["aperture"],
    "aperture_mod": data.get("aperture_mod", 0.0)
    }
        return formatted_presets
        def get_modulator_state(self, source_id: int) -> Optional[Dict[str, Any]]:
    """
    """
    """
    Obtener diccionario de presets de orientación disponibles
        Returns
    -------
    dict
    Diccionario con información de cada preset
    Obtener estado actual del modulador de una fuente
        Parameters
    ----------
    source_id : int
    ID de la fuente
        Returns
    -------
    dict or None
    Estado del modulador o None si no existe
        if source_id not in self.orientation_modulators:
            return None
            
        modulator = self.orientation_modulators[source_id]
        
        return {
            "enabled": modulator.enabled,
            "intensity": modulator.intensity,
            "modulation_shape": modulator.modulation_shape,
            "lfo_frequency": modulator.lfo_frequency,
            "aperture_base": modulator.aperture_base,
            "aperture_modulation": modulator.aperture_modulation,
            "time_offset": modulator.time_offset
        }

    def set_orientation_lfo(self, macro_id: str, frequency: float) -> bool:
    """
    if macro_id not in self._macros:
    logger.error(f"Macro {macro_id} no encontrado")
    return False
        macro = self._macros[macro_id]
    frequency = np.clip(frequency, 0.1, 10.0)
        for sid in macro.source_ids:
    if sid in self.orientation_modulators:
    self.orientation_modulators[sid].lfo_frequency = frequency
        logger.info(f"LFO establecido a {frequency} Hz para macro {macro_id}")
    return True
        def set_orientation_intensity(self, macro_id: str, intensity: float) -> bool:
    """
    Establecer frecuencia LFO del modulador
        Parameters
    ----------
    macro_id : str
    ID del macro
    frequency : float
    Frecuencia en Hz (0.1-10)
        Returns
    -------
    bool
    True si se aplicó correctamente
    Establecer intensidad del modulador
        Parameters
    ----------
    macro_id : str
    ID del macro
    intensity : float
    Intensidad (0.0-1.0)
        Returns
    -------
    bool
    True si se aplicó correctamente
    """
    """
        if macro_id not in self._macros:
            logger.error(f"Macro {macro_id} no encontrado")
            return False
            
        macro = self._macros[macro_id]
        intensity = np.clip(intensity, 0.0, 1.0)
        
        for sid in macro.source_ids:
            if sid in self.orientation_modulators:
                self.orientation_modulators[sid].intensity = intensity
                
        logger.info(f"Intensidad establecida a {intensity:.1%} para macro {macro_id}")
        return True

    def interpolate_orientation_presets(self, macro_id: str, preset1: str, preset2: str, factor: float) -> bool:
    """
    if macro_id not in self._macros:
    logger.error(f"Macro {macro_id} no encontrado")
    return False
        macro = self._macros[macro_id]
    factor = np.clip(factor, 0.0, 1.0)
        for sid in macro.source_ids:
    if sid in self.orientation_modulators:
    self.orientation_modulators[sid].interpolate_presets(preset1, preset2, factor)
        logger.info(f"Interpolación {factor:.1%} entre '{preset1}' y '{preset2}'")
    return True
        def set_orientation_shape(self, macro_id: str, shape: str, scale: Optional[List[float]] = None) -> bool:
    """
        """
        Interpolar entre dos presets de orientación
        
        Parameters
        ----------
        macro_id : str
            ID del macro
        preset1 : str
            Nombre del primer preset
        preset2 : str
            Nombre del segundo preset
        factor : float
            Factor de interpolación (0.0 = preset1, 1.0 = preset2)
            
        Returns
        -------
        bool
            True si se aplicó correctamente
        Configurar forma de modulación manualmente
        
        Parameters
        ----------
        macro_id : str
            ID del macro
        shape : str
            Tipo de forma (circle, ellipse, lissajous, etc.)
        scale : list of float, optional
            Escala en cada eje [yaw, pitch, roll]
            
        Returns
        -------
        bool
            True si se aplicó correctamente
        """
        if macro_id not in self._macros:
            logger.error(f"Macro {macro_id} no encontrado")
            return False
            
        macro = self._macros[macro_id]
        
        for sid in macro.source_ids:
            if sid in self.orientation_modulators:
                modulator = self.orientation_modulators[sid]
                modulator.modulation_shape = shape
                if scale:
                    modulator.shape_scale = np.array(scale)
                    
        logger.info(f"Forma '{shape}' configurada para macro {macro_id}")
        return True

    def toggle_orientation_modulation(self, macro_id: str, enabled: bool) -> bool:
    """
    if macro_id not in self._macros:
    logger.error(f"Macro {macro_id} no encontrado")
    return False
        macro = self._macros[macro_id]
        for sid in macro.source_ids:
    if sid in self.orientation_modulators:
    self.orientation_modulators[sid].enabled = enabled
        state = "activada" if enabled else "desactivada"
    logger.info(f"Modulación {state} para macro {macro_id}")
    return True
        def update(self):
    """
    Activar/desactivar modulación de orientación
        Parameters
    ----------
    macro_id : str
    ID del macro
    enabled : bool
    True para activar, False para desactivar
        Returns
    -------
    bool
    True si se aplicó correctamente
    current_time = time.time()
    dt = 1.0 / self.fps
        # Actualizar estados de movimiento con sistema de deltas
    for source_id, motion in self.motion_states.items():
    if source_id not in self._active_sources:
    continue
        # IMPORTANTE: Sincronizar estado con posición actual
    motion.state.position = self._positions[source_id].copy()
        # Obtener deltas de TODOS los componentes activos
    if hasattr(motion, 'update_with_deltas'):
    deltas = motion.update_with_deltas(current_time, dt)
        # Aplicar cada delta a la posición
    if deltas:
    for delta in deltas:
    if delta and delta.position is not None:
    self._positions[source_id] += delta.position
        # Actualizar estado después del cambio
    motion.state.position = self._positions[source_id].copy()
        # Actualizar el motion (para componentes sin deltas)
        # Actualizar moduladores de orientación si están habilitados
    if self.enable_modulator:
    for source_id, state in self.motion_states.items():
    if source_id in self.orientation_modulators:
    modulator = self.orientation_modulators[source_id]
    if modulator.enabled:
    # Actualizar estado con modulación
    state = modulator.update(current_time, dt, state)
    self.motion_states[source_id] = state
        # Incrementar contador de frames y tiempo
    self._frame_count += 1
    self._time += dt
        # Enviar actualizaciones OSC con rate limiting
    # self\.send_osc_update\(\)  # Temporalmente comentado    """Actualiza el sistema completo"""
